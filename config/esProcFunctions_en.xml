<?xml version="1.0" encoding="UTF-8"?>
<funcs>
<normal>
<F1 desc="Get members of a sequence according to the sequence numbers of members of an integer sequence to create a new sequence." majortype="102" name="A" postfix="" returntype="101">
<options/>
<params>
<P1 desc="p (An integer sequence; the range of its member values is ≥0 and ≤n. If P is an empty sequence, then return an empty sequence.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F1>
<F2 desc="Define a cell name." majortype="101" name="Cr" postfix="" returntype="101">
<options/>
<params/>
</F2>
<F3 desc="The function equals the Excel ACCRINT function" majortype="102" name="Faccrint" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="first_interest    ( The security's first interest date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="settlement (The security's settlement date, i.e. the date after the issue date by which a buyer must pay for the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The issue date of the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="par (The security's par value. If omitted, it takes the default value of zero for ￥100)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F3>
<F4 desc="The function equals the Excel ACCRINTM function" majortype="102" name="Faccrintm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="issue (The security'’s issue date )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="par (The security's par value. If omitted, it takes the default value of zero for 100 yuan)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F4>
<F5 desc="The function equals the Excel COUPNCD function" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F5>
<F6 desc="The function equals the Excel COUPNND function" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPNND function. It returns the previous coupon date before the settlement date for a security. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="p"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F6>
<F7 desc="The function equals the Excel COUPNUN function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F7>
<F8 desc="The function equals the Excel COUPDAYS function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYS function. It returns the number of days in a coupon period that contains the settlement date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F8>
<F9 desc="The function equals the Excel COUPDAYBS function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="It is equivalent to Excel COUPDAYS function and returns the number of days in a coupon period that contains the settlement date. Annually. The day count basis method is US (NASD) 30/360." optionchar="b"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F9>
<F10 desc="The function equals the Excel COUPDAYSNC function" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYSNC function. It returns the number of days from the settlement date to the next coupon date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="n"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F10>
<F11 desc="The function equals the Excel DB function" majortype="102" name="Fdb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost      (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (it must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="month (The number of the months used in the calculation of the first year of depreciation. If omitted, it takes the value of 12 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F11>
<F12 desc="The function equals the Excel DDB function" majortype="102" name="Fddb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost    (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (It must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="factor (The rate of balance declining. If omitted, it takes on the default value of 2 (specifying the double-declining balance method))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F12>
<F13 desc="The function equals the Excel DISC function" majortype="102" name="Fdisc " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F13>
<F14 desc="The function equals the Excel DURATION function" majortype="102" name="Fduration " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="coupon (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F14>
<F15 desc="The function equals the Excel INTRATE function" majortype="102" name="Fintrate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F15>
<F16 desc="The function equals the Excel IRR function" majortype="102" name="Firr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of a series of cash flows used to calculate the internal rate of return. It must contain at least one periodic payment (negative value) and at least one periodic income (positive value))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="guess (An estimated value for IRR function’s calculation. If omitted, it will take on the default value of 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F16>
<F17 desc="The function equals the Excel MIRR function" majortype="102" name="Fmirr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of payment (negative value) and income (positive value) at each of the regular periods . At least one negative value and at least one positive value must be contained)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="finance_rate (The interest rate paid on the money invested)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="reinvest_rate (The interest rate paid on the reinvested cash which is the net income from the regular periods)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F17>
<F18 desc="The function equals the Excel NPER function" majortype="102" name="Fnper" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F18>
<F19 desc="Equivalent to Excel NPVfunction" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F19>
<F20 desc="Equivalent to Excel XNPVfunction" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dates (A sequence of dates corresponding to the array of cash payments. The first date of payment denotes the beginning of the payments for the investment)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F20>
<F21 desc="The function equals the Excel PMT function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0." optionchar="t"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F21>
<F22 desc="The function equals the Excel IPMT function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel IPMT function. It enables to calculate the interest payment for a given period, with constant periodic payment and a constant interest rate" optionchar="i"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F22>
<F23 desc="The function equals the Excel PPMT  function" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PPMT function. It enables to calculate the principal amount during a specific period of an investment or loan that is paid in constant periodic payments, with a constant interest rate" optionchar="p"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F23>
<F24 desc="The function equals the Excel PRICE function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F24>
<F25 desc="The function equals the Excel PRICEDISC function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEDISC function. It calculates the price per ¥100 par value of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F25>
<F26 desc="The function equals the Excel PRICEMAT function" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEMAT function. It calculates the price per ¥100 par value of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F26>
<F27 desc="The function equals the Excel RATE function" majortype="102" name="Frate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="nper (The number of periods over which the investment or loan is to be paid)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The payment amount per period, including the principal and the interest)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, it will take on the default value of zero)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="guess (An estimated interest rate. If omitted, it will take on the assumed value of 10%. Both guess and nper must use the same unit)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F27>
<F28 desc="The function equals the Excel RECEIVED function" majortype="102" name="Freceived" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F28>
<F29 desc="The function equals the Excel SLN function" majortype="102" name="Fsln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F29>
<F30 desc="The function equals the Excel SYD function" majortype="102" name="Fsyd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost   (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period for which the asset’s depreciation is calculated (it must use the same unit as life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F30>
<F31 desc="The function equals the Excel FV function" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to the Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F31>
<F32 desc="The function equals the Excel PV function" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PV function. It enables to calculate the present value of an investment that is the total amount of a series of future payments. For example the amount of borrower’s borrowed money is the present value of the loan delivered by the lender." optionchar="p"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F32>
<F33 desc="The function equals the Excel VDB function" majortype="102" name="Fvdb" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not switch to the straight-line depreciation method when depreciation is greater than the declining balance calculation" optionchar="s"/>
</options>
<params>
<P1 desc="cost  (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="start_period (The starting period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="end_period (The ending period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="factor (The rate of depreciation. If omitted, it takes on the default value of 2, specifying the double-declining balance method)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F33>
<F34 desc="The function equals the Excel YIELD function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F34>
<F35 desc="The function equals the Excel YIELDDISC function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDDISC function. It calculates the annual yield rate of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="0" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F35>
<F36 desc="The function equals the Excel YIELDMAT function" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDMAT function. It calculates the yield rate of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F36>
<F37 desc="Generate an identity matrix of a specified size." majortype="101" name="I" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(A separator if the data file is of text format; it is the sheet name if the file is in format of xls or xlsx; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F37>
<F38 desc="Compute the absolute value of the parameter." majortype="102" name="abs" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the absolute value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F38>
<F39 desc="Compute the arc cosine value of the parameter." majortype="102" name="acos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arc cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F39>
<F40 desc="Return the inverse hyperbolic cosine" majortype="102" name="acosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F40>
<F41 desc="Compute the number of whole years between two specified time points." majortype="102" name="age" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The result is accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="The result is accurate to the month" optionchar="m"/>
</options>
<params>
<P1 desc="dateExp1 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dateExp2 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F41>
<F42 desc="Close connection to Alibaba Cloud." majortype="102" name="ali_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ali_client (A connection to Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F42>
<F43 desc="Connect to Albaba Cloud and return result as a cursor." majortype="102" name="ali_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="ali_url (The URL for accessing Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user (The Access ID for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password (The Access Key for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F43>
<F44 desc="Return a table sequence." majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyValue (Primary key value. If it is a single value, query one record; if it is a sequence, perform batch query on multiple records. When it is a sequence of single values, query one record; when it is sequence of sequences, perform batch query on multiple records.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F44>
<F45 desc="Query a certain part of a table and return the result as a cursor." majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="startValue (The starting value of the primary key values. When it is null or omitted, it represents an infinitesimal; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="endValue (The ending value of the primary key values. When it is null or omitted, it represents an infinite value; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F45>
<F46 desc="Align the records of a record sequence to a sequence, so as to group the record sequence.  If omitting x,y, then align the current records of P with members of A." majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Of P records, return all members which are aligned according to the members of A, and group the resulting sequence. By default, only the first member will be returned." optionchar="a"/>
<O2 defaultselect="false" description="If A is an ordered sequence, the binary search will be used." optionchar="b"/>
<O3 defaultselect="false" description="y is an integer sequence, and every member of y is taken as the alignment position for aligning P to A. P will be aligned to the designated position repeatedly." optionchar="r"/>
<O4 defaultselect="false" description="The return value is composed of the sequence numbers of members in the P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P whose records can be aligned to members of A. Of the result sets, there is an extra group to hold those members whose records fail to be aligned." optionchar="n"/>
<O6 defaultselect="false" description="In P, sort members by the same order as members of A, and put non-corresponding member(s) to A at the tail." optionchar="s"/>
</options>
<params>
<P1 desc="A (Primary record sequence/ primary table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (The field or field expression for association computation of A. You can omit it. If omitted, then it is  interpreted as ~ )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (The alignment expression of P; If omitted, then it is interpreted as P.~)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F46>
<F47 desc="Align the records of a record sequence to a sequence, so as to group the record sequence.  Equivalent to P.align (to(n),y), and support @r." majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Of P records, return all members which are aligned according to the members of A, and group the resulting sequence. By default, only the first member will be returned." optionchar="a"/>
<O2 defaultselect="false" description="If A is an ordered sequence, the binary search will be used." optionchar="b"/>
<O3 defaultselect="false" description="y is an integer sequence, and every member of y is taken as the alignment position for aligning P to A. P will be aligned to the designated position of n overlappedly" optionchar="r"/>
<O4 defaultselect="false" description="The return value is composed of the sequence numbers of members in the P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P whose records can be aligned to members of A. Of the result sets, there is an extra group to hold those members whose records fail to be aligned." optionchar="n"/>
<O6 defaultselect="false" description="In P, sort members by the same order as members of A, and put non-corresponding member(s) to A at the tail." optionchar="s"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (The alignment expression of P;iIt is interpreted as P if omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F47>
<F48 desc="Add a column to or modify a column in a table sequence" majortype="101" name="alter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi(Name of a column to be added)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F`i(Name of a column in the table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F48>
<F49 desc="The function alters fields in a table sequence. " majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="Fi(Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F49>
<F50 desc="Alter one or more fields in an entity table" majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F(Name of the to-be-added field)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F50>
<F51 desc="Perform bitwise operation on integers" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expression based on which you perform the bitwise AND operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F51>
<F52 desc="Perform bitwise operation on integers" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F52>
<F53 desc="Append records in cursor/distributed cursor cs to an entity table T." majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Real-time appending whenever a retrieval happens; force an appending when a composite table is closed; by default an appending is executed only when there is a specified number of new records" optionchar="i"/>
<O2 defaultselect="false" description="Append to a patch file and merge with the existing data for retrieval; create one if there isn’t a corresponding patch file" optionchar="a"/>
<O3 defaultselect="false" description="It is possible that the data in a single cursor corresponds to multiple zones in a multi-zone composite table. In that case the zone expression needs to be calculated at each append" optionchar="x"/>
</options>
<params>
<P1 desc="cs(A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F53>
<F54 desc="Return a list of the current .dfx/.splx file’s argument names." majortype="102" name="arguments" postfix="" returntype="101">
<options/>
<params/>
</F54>
<F55 desc="Get the field values from a record respectively and return them as a sequence" majortype="101" name="array" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F55>
<F56 desc="Transform each record of a table sequence/record sequence and return a sequence of sequences" majortype="101" name="array" postfix="P" returntype="101">
<options/>
<params/>
</F56>
<F57 desc="To abtain the unicode value of the character at the specified position, if it is ASCII character, then return its ASCII code" majortype="102" name="asc" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (The given strings )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nPos  (Integer expression, the default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F57>
<F58 desc="Compute the arc sine value of the parameter." majortype="102" name="asin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arcsine value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F58>
<F59 desc="Return the inverse hyperbolic sine" majortype="102" name="asinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F59>
<F60 desc="Compute the arc tangent value of the parameter." majortype="102" name="atan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Real number for which you want to compute the arctangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F60>
<F61 desc="Return the inverse hyperbolic tangent" majortype="102" name="atanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Any real number between -1 and 1)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F61>
<F62 desc="Retrieve an attached table from a cluster composite table." majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F62>
<F63 desc="Add an attached table to the base table of a composite table." majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(Attached table column, can be omitted; return an attached table named T’ if it is absent; a C preceded by # is a dimension )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F63>
<F64 desc="Compute the average value of the non-null members in a sequence.Equivalent to avg(x1,…,xn)" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params/>
</F64>
<F65 desc="Compute x on each member of the sequence and then compute the average value of the non-null sequence members.Equivalent to A.(x).avg()" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F65>
<F66 desc="Base64-encode the given data" majortype="102" name="base64" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (BLOB data or an ordinary string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Charset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="cs`(Charset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F66>
<F67 desc="Check if Parameter1 is between Parameter 2 and Parameter 3 according to a passed-in parameter." majortype="102" name="between" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The interval is left-open and right-closed" optionchar="l"/>
<O2 defaultselect="false" description="The interval is right-open and left-closed " optionchar="r"/>
<O3 defaultselect="false" description="Make the function returns -1 if x&lt;a; returns 1 if b&lt;x; and retrun 0 for the rest of the cases" optionchar="b"/>
</options>
<params>
<P1 desc="x (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F67>
<F68 desc="Convert a number represented by a certain numeral system to a decimal number" majortype="102" name="bits" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert xi to integer decimal number according to the rules of hexadecimal numeral system if it is the string" optionchar="h"/>
<O2 defaultselect="false" description="First convert xi to an integer if it is the string and then calculate according to the rules of decimal numeral system " optionchar="d"/>
<O3 defaultselect="false" description="Convert to 0 if parameter xi is absent and to 1 if the parameter is present, and then convert them to a decimal number according to the rules of binary system " optionchar="n"/>
<O4 defaultselect="false" description="Won’t convert to a decimal number and should work with another option to return the string forming the number of the corresponding numeral system" optionchar="s"/>
<O5 defaultselect="false" description="Enable returning result as decimal data type" optionchar="b"/>
<O6 defaultselect="false" description="Enable putting lower bits before higher bits" optionchar="r"/>
</options>
<params>
<P1 desc="xi (An integer/string)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F68>
<F69 desc="Convert a blob object into an integer sequence, or vice versa." majortype="102" name="blob" postfix="" returntype="101">
<options/>
<params>
<P1 desc="b(A blob object or an integer sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F69>
<F70 desc="Convert a data object to a boolean value" majortype="102" name="bool" postfix="" returntype="101">
<options/>
<params>
<P1 desc="expression (A constant or an expression that you want to convert to a boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F70>
<F71 desc="Compute an expression against a specified record and return the result.Compute x against the kth member of A" majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (an integer, specifying which record it is)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F71>
<F72 desc="Compute an expression against a specified record and return the result. Compute x against the members of A specified by the integer sequence p " majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p   (an integer sequence, specifying which records they are)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F72>
<F73 desc="Call a script file and return the first result set." majortype="102" name="call" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Disable the default buffer call" optionchar="r"/>
</options>
<params>
<P1 desc="spl (Script file .dfx/.splx)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="arg1 (Parameters)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F73>
<F74 desc="Allocate tasks among a sequence of nodes, execute the script, and return a sequence of values returned by all tasks." majortype="102" name="callx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a random allocation " optionchar="a"/>
<O2 defaultselect="false" description="Enable allocating one task to all available nodes; the task is completed as long as one of the nodes does it successfully, and other nodes are thus terminated" optionchar="l"/>
</options>
<params>
<P1 desc="spl (A script file .dfx/.splx, for which an absolute or a relative path can be set. The relative path is the Search Path under the Tool-&gt;Option-&gt; [Environment] menu.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="...(The parameter for passing value to dfx. It is usually in the form of a sequence. The number of parameters to be passed to dfx is the number of the sequences. The parallel algorithm will divide a computational task into multiple subtasks according to the length of the parameter sequence and pass each member of the sequence to the corresponding subtask as the parameter value of dfx.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs (The server sequence in which each server is represented by a string in the form of &quot;address:port number&quot;, like &quot;192. 168. 0. 86: 4001&quot;.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rdfx(A dfx script used that uses two parameters; it is used to perform reduce action, and can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F74>
<F75 desc="Perform the logical AND operation over members of a table sequence" majortype="102" name="cand" postfix="A." returntype="102">
<options/>
<params/>
</F75>
<F76 desc="Create canvas object" majortype="102" name="canvas" postfix="" returntype="101">
<options/>
<params/>
</F76>
<F77 desc="Return the value of the expression that satisfies the specified condition." majortype="102" name="case" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Judge expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Value expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="yi (result expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="y  (Default expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F77>
<F78 desc="Truncate the data at the specified position, and carry the remaining part if any." majortype="102" name="ceil" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be truncated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer number for specifying the truncation position;taken as 0 when it is omitted＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F78>
<F79 desc="Return an Excel cell name according to specific row and column" majortype="102" name="cellname" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r(The rth row in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c(The cth column in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F79>
<F80 desc="Perform grouping and aggregation over a pre-summarized data cube" majortype="101" name="cgroups" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="m"/>
</options>
<params>
<P1 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(Aggregate function)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi(Field names in result set)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="w(Filtering condition)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F80>
<F81 desc="Create a channel." majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params/>
</F81>
<F82 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to cs.push(channel())" majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cs (A cursor or A cluster cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F82>
<F83 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to ch.push(channel())" majortype="102" name="channel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ch (A channel or A cluster channel)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F83>
<F84 desc="According to the given Unicode or ASCII code, get the corresponding characters" majortype="102" name="char" postfix="" returntype="101">
<options/>
<params>
<P1 desc="int (Integer expression, Unicode code or ASCII code)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F84>
<F85 desc="Auto-identify the characer set used for a string or a text file." majortype="102" name="chardetect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Identify the character set used for a string or a binary value" optionchar="v"/>
</options>
<params>
<P1 desc="param(The to-be-identified string or binary vlaue, name of the text file to be identified, or object/URL of the text file to be identified)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F85>
<F86 desc="Generate the binary value of a string according to the character set the latter uses, or vice versa." majortype="102" name="charencode" postfix="" returntype="102">
<options/>
<params>
<P1 desc="str(A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="rawtest(A binary value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="charset(A character set, such as UTF-8 and GB2312; default is the one currently used by the system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F86>
<F87 desc="A chi-square inverse cumulative distribution function." majortype="102" name="chi2inv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(The p-value within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v(Degrees of freedom (DF))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F87>
<F88 desc=" Write a number with the Chinese numerals" majortype="102" name="chn" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Write the specific number with the Chinese numeral system in the format of billion, ten thousand, thousand, hundred, ten in order" optionchar="a"/>
<O2 defaultselect="false" description="Write the specific number with upper case Chinese numerals" optionchar="u"/>
<O3 defaultselect="false" description="Write the specific number using Chinese characers used for numbers on renminbi banknotes" optionchar="b"/>
</options>
<params>
<P1 desc="x(If a function doesn’t work with an option or uses @a and @u options, parameter x should be an integer; if it cooperate with @b option, parameter x should be a float)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F88>
<F89 desc="Set system clipboard content." majortype="101" name="clipboard" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="If the clipboard content comes from Excel, record it to return; otherwise the function will return the content previously copied." optionchar="e"/>
</options>
<params>
<P1 desc="s (The content to be copied to clipboard, whose data type can be table sequence, string, numeric, date, time, and datetime; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F89>
<F90 desc="Close a cursor." majortype="101" name="close" postfix="cs." returntype="101">
<options/>
<params/>
</F90>
<F91 desc="Close a datasource connection." majortype="1" name="close" postfix="db." returntype="102">
<options/>
<params/>
</F91>
<F92 desc="Close a composite table or a cluster table." majortype="1" name="close" postfix="T." returntype="102">
<options/>
<params/>
</F92>
<F93 desc="Compare the value of two expressions x and y.When comparing the value of two expressions x and y, return 0 if they are equal; return 1 if x is greater than y; return -1 if x is less than y. Note:An error will be reported if x and y cannot be compared." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F93>
<F94 desc="Compare  two sequences A and B.When comparing two sequences A and B, compare the two members in the same position of A and B one by one. Return 0 if all the members are equal; for the first members those are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller.An error will be reported if A and B cannot be compared. If the members in the sequence A and B are not the same, and their beginning members are the same, then the value with less members will be smaller." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A   (an n sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B   (an m sequence. If sequence B does not exist, then it will be taken as a 0 sequence by default, that is, comparison will be done between sequences A and [0…0])" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F94>
<F95 desc="When the lengths of sequences A and B are equal, compare members of them in normal order; return 1 if a member in A is larger and return -1 if a member in A is smaller and return 0 if all members are equal. If the length of sequence A is less than that of sequence B, return 1 if a member in A is larger and return -1 if a member in A is smaller; return -1 if members of sequence A are equal to their counterparts in sequence B.  When sequences A and B have same number of members, return 0 if all members are equal, otherwise compare members of them in a normal order; for the first members that are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller. Return 0 if the number of members in the two sequences are not the same and if the length of sequence A is greater than or equal to that of sequence B and if members in sequence B are equal to their counterparts in sequence A. " majortype="102" name="cmp" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B (A sequence whose length is m; can be a single value which is regarded as a sequence having one member )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F95>
<F96 desc="When parameter B is absent, sequence B is by default a sequence having members of 0s, then the comparison becomes one happening between sequence A and sequence [0…0] of the same lengh." majortype="101" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F96>
<F97 desc="Compare two records r1 and r2. An error will be reported if r1 and r2 cannot be compared." majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r1 (Record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r2 (Record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F97>
<F98 desc="Return the number of combinations." majortype="102" name="combin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (An integer that is the number of given objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of elements you want to pick from the given set of objects)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F98>
<F99 desc="Commit the database transaction manually." majortype="1" name="commit" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params/>
</F99>
<F100 desc="Concatenate parameters into a string." majortype="102" name="concat" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Any value that can be converted to a string; if it is a sequence, it will be broken up before concatenation.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F100>
<F101 desc="Concatenate members of a sequence with the delimiter and return result as a string." majortype="101" name="concat" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add quotation marks to string members when concatenating them into a string. If this option is omitted, do not use the quotation marks." optionchar="q"/>
<O2 defaultselect="false" description="Concatenate with the comma" optionchar="c"/>
<O3 defaultselect="false" description="Enclose string members to be concatenated with single quotes" optionchar="i"/>
<O4 defaultselect="false" description="If members of the sequence are also sequences, create a newl line after concatenate members of each sequence members with the delimiter. The operations are equivalent to A.(~.concat(d)).concat(&quot;\n&quot;). If there are other options, perform the concatenation in the inner layer of the function. " optionchar="n"/>
</options>
<params>
<P1 desc="d (Delimiter)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F101>
<F102 desc="Get concatenation of all sequence-type members in a sequence." majortype="101" name="conj" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Recursively concatenate members until there isn’t any sequence members" optionchar="r"/>
</options>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F102>
<F103 desc="Split each of the records in a channel, union the members and return the resulting union as a channel." majortype="101" name="conj" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="...  (An expression that returns a record sequence/table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F103>
<F104 desc="Split each of the records in a cursor, union the members and return the original cursor. " majortype="101" name="conj" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="... (An expression that returns a record sequence (or a table sequence))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F104>
<F105 desc="Union the members of a cursor sequence, and return result as a cursor." majortype="101" name="conjx" postfix="CS." returntype="101">
<options/>
<params/>
</F105>
<F106 desc="Establish a connection to a database." majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="dataSource (The name of a data source)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F106>
<F107 desc="Connect to a database through its driver and url in which the user name and password are written" majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="drv (Database driver class)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="url (Database driver connection URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F107>
<F108 desc="Return the connection to a data source in the file system" majortype="102" name="connect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params/>
</F108>
<F109 desc="Check whether a given data object is a member of a certain sequence." majortype="101" name="contain" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The option means that sequence A is ordered, based on which a binary search is performed in an ascending or descending order" optionchar="b"/>
</options>
<params>
<P1 desc="xi  (Data object, which can be a number, a string or a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F109>
<F110 desc="Perform logical OR operation over members of a sequence." majortype="101" name="cor" postfix="A." returntype="101">
<options/>
<params/>
</F110>
<F111 desc="Compute the cosine value" majortype="102" name="cos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (The radian number of the cosine to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F111>
<F112 desc="Return the hyperbolic cosine" majortype="102" name="cosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F112>
<F113 desc="Compute x with each member of the sequence and then count the number of non-null sequence members of the new sequence.  Equivalent to A.(x).count()" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x  (Generally an expression of a single field name, or a legal expression composed of multiple field names.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F113>
<F114 desc="Count the number of non-null members in a sequence.Equivalent to count(x1,…,xn)" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params/>
</F114>
<F115 desc="Calculate the covariance between two vectors." majortype="101" name="cov" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F115>
<F116 desc="Calculate the covariance matrix for a matrix." majortype="101" name="covm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F116>
<F117 desc="Create an empty table sequence." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi    (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F117>
<F118 desc="Create an empty table sequence with one or more keys set." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="#Fi  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F118>
<F119 desc="Open a composite table." majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="p (Write password/read password)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F119>
<F120 desc="Create a composite table from a corresponding file." majortype="2" name="create" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Do not compress the file; default is to compress it" optionchar="u"/>
<O2 defaultselect="false" description="Generate a rowwise file while default is columnar storage, which does not support the multicursor" optionchar="r"/>
<O3 defaultselect="false" description="Force to re-create the file even if the target file already exists; defalut is to terminate computation and report error" optionchar="y"/>
<O4 defaultselect="false" description="egment by the first field" optionchar="p"/>
</options>
<params>
<P1 desc="C(A column of the would-be composite table)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(A zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F120>
<F121 desc="Create an empty table sequence by duplicating the data structure of table sequence T." majortype="101" name="create" postfix="T." returntype="101">
<options/>
<params/>
</F121>
<F122 desc="Create a table sequence by copying the data structure of a specified record." majortype="101" name="create" postfix="r." returntype="101">
<options/>
<params/>
</F122>
<F123 desc="Generate a new empty table sequence by copying data structure of a specific record sequence" majortype="101" name="create" postfix="P." returntype="101">
<options/>
<params/>
</F123>
<F124 desc="Create a new composite table file using the data structure of an existing composite table" majortype="101" name="create" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="f(A composite table file or a file group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(An integer, which is the zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F124>
<F125 desc="Store the result set of grouping an entity table or a multi-zone composite table as a pre-summarized data cube" majortype="101" name="cuboid" postfix="" returntype="101">
<options/>
<params>
<P1 desc="C(Pre-summarized data cube name; delete the pre-summarized cube with the specified name when only this parameter is present)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate function, support only sum/count/max/min/top/iterate; when working with iterate(x,a;Gi,…) function, parameter Gi isn’t supported )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Gi(Field name in result set)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F125>
<F126 desc="An interative loop to get a cumulative value over records in which one of its fields has same values." majortype="102" name="cum" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F126>
<F127 desc="Call a cellset file and return the resut set returned from the execution of the file as a cursor." majortype="102" name="cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The dfx can be represented by a cell that corresponds to a subroutine defined by func() function" optionchar="c"/>
</options>
<params>
<P1 desc="dfx (cellset file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (dfx parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F127>
<F128 desc="Generate a cursor from a sequence." majortype="101" name="cursor" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="With the option, the A.cursor@m(n) function returns a multicursor; n is the number of segements and can be omitted;cursor@m(mcs,K:K’,...) divides an ordered sequence into several segments according to segmenting key K:K’ in sync with ordered multicursor mcs and returns them as a multicursor, too. " optionchar="m"/>
</options>
<params>
<P1 desc="k (Segment number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of data segments; retrieve all data out when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F128>
<F129 desc="Create a database cursor by executing an SQL statement and return it." majortype="1" name="cursor" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="If the result set has only one column, the content of the returned cursor is a sequence" optionchar="i"/>
<O2 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type" optionchar="d"/>
<O3 defaultselect="false" description="Disconnect from the database automatically when the cursor is closed. This option applies to the database connection with connect only" optionchar="x"/>
</options>
<params>
<P1 desc="sql  (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args   (If there are parameters in the sql, they must be converted into arguments; args can be either constants or expressions. Note: Arguments shall be separated by commas)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F129>
<F130 desc="Connect to esProc-ODBC data source db to call the specified dfx file, and return result as a cursor" majortype="1" name="cursor" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="If the result set has only one column, the content of the returned cursor is a sequence" optionchar="i"/>
<O2 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type" optionchar="d"/>
<O3 defaultselect="false" description="Disconnect from the database automatically when the cursor is closed. This option applies to the database connection with connect only" optionchar="x"/>
</options>
<params>
<P1 desc="call dfx() (Dfx is a cellset file; can be specified using a relative path, which is relative to the search path, or an absolute path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (If there are parameters in the SQL, they must get assigned; their values can be actual ones or args specified in query statement Note: Parameters shall be separated by commas )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F130>
<F131 desc="Create a cursor based on a file." majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q and @m. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor." optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="With the option, the function - f.cursor@m(Fi:type,…;,s) – returns a multicursor." optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem recordmewmm" optionchar="v"/>
</options>
<params/>
</F131>
<F132 desc="Create a cursor based on a file." majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="se the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q and @m. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor." optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O9 defaultselect="false" description="With the option, the f.cursor@m(Fi:type,…;n,s) function returns a multicursor;  parameter n is the number of segments and can be omitted" optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
<O15 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are treated as quotes" optionchar="a"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O17 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O18 defaultselect="false" description="Allow line continuation if there is an escape character \ at the end of the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi (Fields to be retrieved; all fields will be retrieved by default. The to-be-retrieved field(s) can be represented by their sequence numbers headed by the sign #.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types. Include bool, int, long, float, decimal,  string, date, time and datetime),Data type of the first row will be used by default." filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k  (The segment number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(The number of segments. Retrieve the whole file when both k and n are omitted )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (The number of segments. Retrieve the whole file when both k and n are omitted  )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F132>
<F133 desc="Segment an entity table or an in-memory table and return the cursor of a specified segment." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The T.cursor@m(x:C…;wi,...;n) function with this option generates a multicursor segmented into n parts. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent" optionchar="m"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and their relationships are AND. You can use the following three types of syntax in a filtering condition: 1. K:Ti  K is a field in the entity table; Ti is a table sequence whose primary key is K. The expression filters away records where K=Ti.find(K) is false. When K is not a selected field to be output, just do the filtering as usuall. 2.K:Ti:null  Filter away all records that can be found. 3.K:Ti:#  K=Ti(K); locate corresponding records using sequence numbers and delete those out-of-range ones and those where Ti(K) is false or null. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k (A positive integer (k≤n) representing the kth segment )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (A positive integer representing the number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F133>
<F134 desc="Return the specified column(s) in a cluster entity table/cluster memory table as a cluster cursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The function with this option generates a cluster multicursor synchronously segmented into n parts and splits a duplicate table on two levels. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent. " optionchar="m"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false.By default the whole result set is retrieved)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F134>
<F135 desc="Synchronously segment an entity table according to a multicursor and return a multicursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Perform matching using the multicursor’s first field of the key" optionchar="k"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi (Filtering condition; multiple conditions are separated by comma(s) and their relationships are AND. You can use the following three types of syntax in a filtering condition: 1. K:Ti  K is a field in the entity table; Ti is a table sequence whose primary key is K. The expression filters away records where K=Ti.find(K) is false. When K is not a selected field to be output, just do the filtering as usuall. 2.K:Ti:null  Filter away all records that can be found. 3.K:Ti:#  K=Ti(K); locate corresponding records using sequence numbers and delete those out-of-range ones and those where Ti(K) is false or null. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="msc (A multicursor generated from an entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F135>
<F136 desc="Synchronously segment a cluster entity table according to a cluster multicursor and return a cluster multicursor." majortype="101" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x(Expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(To-be-displayed columns; by default all columns are displayed)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filering condition;  multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false. By default the whole result set is retrieved)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="mcs(A cluster multicursor generated from a cluster entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F136>
<F137 desc="Segment a memory table/cluster memory table and return cursor of the specified segment." majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="T.cursor@m(...;n) returns a multicursor segmented into n parts; n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent " optionchar="m"/>
</options>
<params>
<P1 desc="C(Column name in the memory table)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k(A positive integer (k≤n) representing the kth segment)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(A positive integer representing the number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F137>
<F138 desc="Divide a memory table in sync with a memory multicursor and return it also as a memory multicursor." majortype="102" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="..." filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="mcs(A multicursor generated from a memory table or a composite table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F138>
<F139 desc="Merge subcursors in a multicursor into a single cursor or a new multicursor with a smaller number of parallel subcursors." majortype="101" name="cursor" postfix="mcs." returntype="101">
<options/>
<params>
<P1 desc="n(Subcursor column name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F139>
<F140 desc="Get the date part of the datetime value." majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (Datetime value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F140>
<F141 desc="Convert stringExp to a date value according to the format defined by format and return null if the conversion fails; parameter loc is the language used in stringExp; the default is the system language" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F141>
<F142 desc="The format of the result returned by stringExp should be in consistent with the date format in configuration information; if time is contained in the result, the time will not be converted; return null if the conversion fails" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F142>
<F143 desc="Convert year,month,day of integer type to date type; return null if the conversion fails" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="year (Integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="month (Integer) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="day (Integer )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F143>
<F144 desc="Convert integer ym and day into date data" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="day (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F144>
<F145 desc="Convert long integer longExp to date type data" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="longExp(64-bit loing integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F145>
<F146 desc="Return the time and date of a file last modified." majortype="2" name="date" postfix="f." returntype="101">
<options/>
<params/>
</F146>
<F147 desc="Adjust the precision of the datetime expression and return it." majortype="102" name="datetime" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
</options>
<params>
<P1 desc="datetimeExp (datetime value )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F147>
<F148 desc="Convert the data type of string to datetime type according to the format defined by format and return null if the conversion fails; if parameter format doesn’t exist, the format of string of string type should be the same as the format of datatime value in configuration informationt; parameter loc is the language used in stringExp; the default is the system language" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F148>
<F149 desc="Convert long of long integer type to datetime value" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="long (Long integer counted in microseconds)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F149>
<F150 desc="Concatenate date type data and time type data into data of datetime type" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="date (Date type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="time (Time type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F150>
<F151 desc="Convert y,m,d,h,m,s of integer type to datetime data" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="y   (Positive integer, year)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m  (Positive integer, month)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="d  (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="h  (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="s  (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F151>
<F152 desc="Convert integer ym, d, h, m, s into datetime data" majortype="102" name="datetime" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit positive integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="d (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F152>
<F153 desc="Get the day from a date value." majortype="102" name="day" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the day of the week from the specified date. For Sunday, return 1; For Monday, return 2, and so on. By default, get the day of the month from the specified date." optionchar="w"/>
</options>
<params>
<P1 desc="dateExp     (Date expression whose result must be the date or the string of Chinese date and time format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F153>
<F154 desc="Get the number of days of the year, quarter or month to which the specified date belongs." majortype="102" name="days" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the number of days of the quarter to which the specified date belongs" optionchar="q"/>
<O2 defaultselect="false" description="Get the number of days of the year to which the specified date belongs By default get the number of days of the month to which the specified date belongs " optionchar="y"/>
</options>
<params>
<P1 desc="dateExp     (A date or a date string of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F154>
<F155 desc="Convert a string or a numeric value to a big decimal number" majortype="102" name="decimal" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F155>
<F156 desc="Delete specified records from a table sequence.  Delete the kth record" majortype="102" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A positive integer, which specifies the position of a record to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F156>
<F157 desc="Delete specified records from a table sequence.  Delete the records whose sequence numbers exist in p" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p (An integer sequence with the length of n, which specifies the positions of the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F157>
<F158 desc="Delete specified records from a table sequence.  Delete the records that exist in sequence  A" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="A (A sequence, which specifies the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F158>
<F159 desc="Delete the kth member" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A positive integer that indicates the position of a member to be deleted in the sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F159>
<F160 desc="Delete the members whose sequence numbers exist in p" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p  (An integer sequence with the length of n that specifies the positions of the members to be deleted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F160>
<F161 desc="Delete specified record(s) from an entity table." majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record(s)  from the record sequence" optionchar="n"/>
</options>
<params>
<P1 desc="P  (A record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F161>
<F162 desc="Compare the specified two dates." majortype="102" name="deq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="Accurate to the quarter" optionchar="q"/>
<O3 defaultselect="false" description="Accurate to the month" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to the ten-day period" optionchar="t"/>
<O5 defaultselect="false" description="Accurate to the week" optionchar="w"/>
</options>
<params>
<P1 desc="datetimeExp1 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="datetimeExp2 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F162>
<F163 desc="Add one or more fields to a table sequence or a record sequence. " majortype="101" name="derive" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks to enhance performance; no definite order for the records in the result set. " optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if there is expression xi and its result is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
<O3 defaultselect="false" description="@x(…;n) Unfold original fields whose values are records into n levels; default of n is 2" optionchar="x"/>
</options>
<params>
<P1 desc="xi      (Expression, whose results are used as the values of the derived fields )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi      (Field name, which shouldn’t have the same name as any of the original fields in P)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F163>
<F164 desc="Generate a table sequence according to a record sequence." majortype="101" name="derive" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Do not copy the record sequence’s data structure, which will change the record sequence’s structure and which will adjust the number of fields as needed. The option will achieve a better performance as well as an increased risk of error. It’s recommended to be used only when the original record sequence is no longer needed. " optionchar="o"/>
</options>
<params/>
</F164>
<F165 desc="Add fields to records in a channel." majortype="101" name="derive" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a corresponding record if there is expression xi  and its result is null; won’t affect the field values of existing fields." optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose results will be the values of the new fields)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name, which shouldn’t be same as one of the existing ones)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F165>
<F166 desc="Add one or more fields to a cursor." majortype="101" name="derive" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if there is expression xi and its result  is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
</options>
<params>
<P1 desc="xi (Expression, whose computed results are the field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi ( Field name. In this case, Fi cannot be of the same name to the existing fields in cs )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F166>
<F167 desc="Calculate the determinant of a square matrix." majortype="101" name="det" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F167>
<F168 desc="Generate a new sequence by removing from the first sub-sequence of a sequence the members that exist in the other sub-sequences of the sequence." majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params/>
</F168>
<F169 desc="Calculate difference between the sequence-type members in a specified sequence to generate a new sequence where the first subsequence won’t contain members that exist in the other sub-sequences. " majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression that returns a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F169>
<F170 desc="Convert a numeric string of certain numeral system to a specific numeral system" majortype="102" name="digits" postfix="" returntype="102">
<options/>
<params>
<P1 desc="x(Numeric string; use letters to represent a number greater than 10 )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ds(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dd(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F170>
<F171 desc="List the file name(s) satisfying a wildcard path." majortype="101" name="directory" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List the subdirectory ofpath" optionchar="d"/>
<O2 defaultselect="false" description="List the name of returned file, and the returned results will enclose the name of full path" optionchar="p"/>
<O3 defaultselect="false" description="Create directory" optionchar="m"/>
<O4 defaultselect="false" description="Delete record and the record must be null" optionchar="r"/>
<O5 defaultselect="false" description="Perform recursive query to get all file names under all subdirectories; mutually exclusive with @m and @r" optionchar="s"/>
<O6 defaultselect="false" description="Make case-insensitive; without it the OS will have a say" optionchar="c"/>
</options>
<params>
<P1 desc="path   (wildcard path, * indicates 0 or several characters, and ? indicates a single character)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F171>
<F172 desc="Calculate the Euclidean distance between two vectors." majortype="101" name="dis" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate the sum of absolute values of the differences between numbers at same positions in vector A and vector B" optionchar="a"/>
<O2 defaultselect="false" description="Average out the Euclidean distance before getting its square root " optionchar="m"/>
</options>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F172>
<F173 desc="Calculate Mahalanobis distance between two vectors on covariance matrix. " majortype="101" name="dism" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(A covariance matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F173>
<F174 desc="Draw canvas" majortype="101" name="draw" postfix="G." returntype="101">
<options>
<O1 defaultselect="false" description="Return a JPG canvas" optionchar="j"/>
<O2 defaultselect="false" description="Return a GIF canvas" optionchar="g"/>
<O3 defaultselect="false" description="Return a PNG canvas" optionchar="p"/>
</options>
<params>
<P1 desc="w (Width of canvas in pixels)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h (Height of canvas inpixels)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F174>
<F175 desc="Join up cluster memory table into a local memory table." majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params/>
</F175>
<F176 desc="Copy a local memory table onto nodes to create a duplicate cluster memory table." majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="h(A node or a node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F176>
<F177 desc="Close connection to Amazon DynamoDB." majortype="102" name="dyna_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="dyna_open(DynamoDB connecton)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F177>
<F178 desc="Connect to Amazon DynamoDB." majortype="102" name="dyna_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="dyna_url(URL for accessing DynamoDB)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="region(The AWS service region for use)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="AccessKey(Access Key for accessing DynamoDB; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="SecretKey(Secret Key for accessing DynamoDB; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F178>
<F179 desc="Query data stored in DynamoDB." majortype="102" name="dyna_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="dyna_open(The DynamoDB connection object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F179>
<F180 desc="Get the date/time which is a certain time period before or after a given date/time." majortype="102" name="elapse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the date which is n years before or after the specified date." optionchar="y"/>
<O2 defaultselect="false" description="Compute the date which is n quarters before or after the specified date." optionchar="q"/>
<O3 defaultselect="false" description="Compute the date which is n months before or after the specified date." optionchar="m"/>
<O4 defaultselect="false" description="If the specified date is the last day of a month, the new date will not be adjusted to the last day of the month to which it belongs. Without the option the new date will be automatically adjusted to the last day of the corresponding month. This option works with @yqm." optionchar="e"/>
<O5 defaultselect="false" description="Compute the datetime which is n seconds before or after the specified datetime" optionchar="s"/>
<O6 defaultselect="false" description="Compute the datetime which is n milliseconds before or after the specified datetime; by default the function computes the date which is n days after the specified date." optionchar="ms"/>
</options>
<params>
<P1 desc="dateExp (A specified date expression that should return a date or a string of standard date format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer expression according to which a date/time n days/years/months/seconds after or before a given date/time is computed, depending on whether n is positive or negative.) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F180>
<F181 desc="An external libaray function that builds models and performs predictions using the elastic net regression method." majortype="102" name="elasticnet" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="l1(Coefficient 11; default is 0.9)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="l2(Coefficient 12; default is 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F181>
<F182 desc="Generate a new record sequence by performing enumeration grouping on an record sequence according to another record sequence." majortype="101" name="enum" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Repetitive enum, that is, allocate a certain record of P to multiple groups. " optionchar="r"/>
<O2 defaultselect="false" description="The return value is composed of the sequence numbers of members that exist in P" optionchar="p"/>
<O3 defaultselect="false" description="Group P’s records according to E’s members and return the result groups. In the result set, there is a group to store the unaligned member(s)." optionchar="n"/>
</options>
<params>
<P1 desc="E (Record sequence/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (A field name or an expression in P. y is allowed to be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F182>
<F183 desc="Assign value to the global variable." majortype="102" name="env" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the global variable v as a task variable" optionchar="j"/>
</options>
<params>
<P1 desc="v (The global variable )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Variable value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F183>
<F184 desc="Judge if a sequence can be generated by swapping the positions of the members of another sequence" majortype="101" name="eq" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="B    (a sequence expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F184>
<F185 desc="Obtain the last error information from a database connection." majortype="1" name="error" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Use the option to return information in string" optionchar="m"/>
</options>
<params/>
</F185>
<F186 desc=" Close REST Client connection." majortype="102" name="es_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F186>
<F187 desc="Execute the delete command and return a boolean value." majortype="102" name="es_delete" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or a block of data in JSON format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F187>
<F188 desc="Execute the get command and return a table sequence or a cursor." majortype="102" name="es_get" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor and by default return all records" optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a filefd" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F188>
<F189 desc="Execute head command and return a table sequence." majortype="102" name="es_head" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(The address of to-be-checked document/record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F189>
<F190 desc="Connect to Elasticsearch (ES) server in the default http protocol. " majortype="102" name="es_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The https protocol" optionchar="s"/>
</options>
<params>
<P1 desc="host(URL of the ES server, the format is: http(s)://hostname:port, in which http(s) can be omitted; the default is http protocol)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(Username for connectiong to an ES server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="passwd(Password for connectiong to an ES server)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F190>
<F191 desc="Execute the post command and return a table sequence or a cursor." majortype="102" name="es_post" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor " optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F191>
<F192 desc=" Execute the put command and return a table sequence." majortype="102" name="es_put" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F192>
<F193 desc="Dynamically parse and compute the expression" majortype="102" name="eval" postfix="" returntype="101">
<options/>
<params>
<P1 desc="StringExp (An expression string to be calculated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="argExp (Parameter expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F193>
<F194 desc="Execute the SQL statement sql in database db. args,… is the parameter of sql, which can also be a sequence consisting of parameter values" majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="sql      (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args     (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F194>
<F195 desc="Execute the SQL statement sql in database db over sequence A. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="A            (A sequence. the SQL statement is executed on each member of A. Generally args is computed against each member of A and the value is passed to the SQL statement for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql         (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args      (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F195>
<F196 desc="Execute the SQL statement sql in database db over cursor cs. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." majortype="1" name="execute" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F196>
<F197 desc="Check if a file exists." majortype="2" name="exists" postfix="f." returntype="101">
<options/>
<params/>
</F197>
<F198 desc="Compute e to the nth power." majortype="102" name="exp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (The exponent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F198>
<F199 desc="Convert a sequence into a string." majortype="102" name="export" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The column name will be written to the beginning of the character string as the first record." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O4 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O5 defaultselect="false" description="Perfrom escaping according to the Excel rule, which treats two double quotation marks as one and does not escape the other characters Need to work with @q" optionchar="o"/>
</options>
<params>
<P1 desc="x (Fields to be exported. If omitted, then export all fields of A.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Name of the resulting field in the string. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (User-defined field separator. The default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F199>
<F200 desc="Write a sequence/table sequence/record sequence into a file." majortype="2" name="export" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. By default, overwrite the original file. The option and @t are mutual exclusive. The appended records and the original records should be of the same structure, otherwise error will be reported" optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing. It ignores @t and does not support the parameter s." optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s, when it exists, is the grouping expression according which sequence A is ordered; perform data segmentation only when s changes. The option is used to export a large amount of data to a binary file with parallel processing in segments, which can make sure the integrity of records in each segment. " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="" optionchar="o"/>
</options>
<params>
<P1 desc="A    (The record sequence/sequence to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x     (The field to be exported. If omitted, all the fields of A that can be textualized will be exported. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F     (Resulting field name. If omitted, then use the original field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s     (The user-defined separator used in the text file, and the default separator is tab)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F200>
<F201 desc="Retrieve data from a cursor and write it to a text file." majortype="2" name="export" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. If omitting , overwrite the original file. This option cannot co-exist with @t. f and cs must be of the same structure, otherwise error will be reported." optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing. It ignores @t and does not support the parameter s." optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s is the grouping expression ruling that sequence A is ordered by s, if the parameter exists, and perform the segmentation only when s changes. The binary file is used to export a large sequenece in segments with parallel processing, which will make sure records in each segment won’t be split.  " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system. " optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
</options>
<params>
<P1 desc="cs (Cursor whose data to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Fields to be exported. If omitted, then export all fields in the record sequence A that can be textualized. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (Resulting field name. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.b)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F201>
<F202 desc="Create a matrix whose major diagonal element is 1 and other elements are 0." majortype="102" name="eye" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n1/n2(Positive integers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F202>
<F203 desc="Perform an aggregate operation over an attached table’s column" majortype="102" name="f" postfix="T." returntype="102">
<options/>
<params>
<P1 desc="T (An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (An attached table’s column)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F203>
<F204 desc="Compute the factorial of the parameter." majortype="102" name="fact" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nExp (Data for which you want to compute the factorial)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F204>
<F205 desc="Fetch one or more records from a cursor/distributed cursor" majortype="101" name="fetch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t actually fetched out the selected data from the cursor. The option enables an action functionally equivalent to copying the data; it doesn’t support x." optionchar="0"/>
<O2 defaultselect="false" description="Close the cursor after data is fetched." optionchar="x"/>
<O3 defaultselect="false" description="Return a table sequence" optionchar="o"/>
</options>
<params>
<P1 desc="n ( An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, according to which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F205>
<F206 desc="Fetch and store the existing data in a channel." majortype="101" name="fetch" postfix="ch." returntype="101">
<options/>
<params/>
</F206>
<F207 desc="Get records from a multicursor." majortype="101" name="fetch" postfix="mcs" returntype="101">
<options/>
<params/>
</F207>
<F208 desc="Get the value of a specified field in a record." majortype="101" name="field" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F    (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F208>
<F209 desc="Modify a value of the specified field of a record." majortype="101" name="field" postfix="r." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Expression whose computing result is the value of the Fth field, or the value of the string parameter F.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F209>
<F210 desc="Get values of a specified field of a sequence." majortype="101" name="field" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="When the return value is a record or record sequence, loop its members iteratively to get desired values" optionchar="r"/>
</options>
<params>
<P1 desc="F  (The sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F210>
<F211 desc="Modify the value of a specified field in a sequence." majortype="101" name="field" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (A sequence whose length is equal to the number of values in Fth field, or a single value, which can be considered as a sequence in which members have the same value and their number is equal to the number of values in Fth field.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F211>
<F212 desc="Open a file with the specified name. " majortype="101" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Search the file names on the non-absolute paths in a specified order: Class path -&gt; Search path-&gt; Main path. The search path is the one configured on the option menu of esProc, and the default main path is the current directory. With this option, the function returns the name of a read-only file. " optionchar="s"/>
<O2 defaultselect="false" description="Generate a temporary file under the directory of fn file. Without the fn file, create the temporary file through the Tempory directory, one of esProc options under the Tool menu. When the relative path is used to point to the temporary directory, it is relative to the configured main directory" optionchar="t"/>
<O3 defaultselect="false" description="Make the write action wait when sharing violation happens" optionchar="a"/>
</options>
<params>
<P1 desc="fn(Name of the file to load. Both the absolute path and the relative path are acceptable. If using the relative path, then it is relative to the main path, which is the one configured on the option menu of esProc, and which by default is the current directory (the directory holding the script file) )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which supports jvm's built-in character set and which by default is the default value set by OS)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F212>
<F213 desc="Generate a new cluster file that has same distribution type as an existing cluster file." majortype="102" name="file" postfix="" returntype="2">
<options/>
<params>
<P1 desc="fn  (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F213>
<F214 desc="Return a file or file group preceded by the corresponding zone table number(s). " majortype="101" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A composite table file.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F214>
<F215 desc="Return a remote file from a node" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F215>
<F216 desc="Return a remote file from a sequence of nodes" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F216>
<F217 desc="Generate a cluster file or a cluster homo-name files group on one or more nodes" majortype="102" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a remote generation with parameter z and parameter hs have a one-one-one correspondence; and is equivalent to to(hs.len()) when parameter z is absent" optionchar="w"/>
</options>
<params>
<P1 desc="fn(A composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number(s), which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A node or a sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F217>
<F218 desc="Generate a new cluster homo-name files group using the distribution style of an existing homo-name files group" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A would-be cluster homo-name files group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number, which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f(A cluster homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F218>
<F219 desc="Create a new string by concatenating strings together." majortype="102" name="fill" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Source strings for making up a new string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Number of source strings that constitute the new string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F219>
<F220 desc="Find a record according to its primary key value." majortype="101" name="find" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the dichotomizing search. Here, A must be ordered by the primary key; otherwise, the result will be wrong, and the index table will be ignored." optionchar="b"/>
<O2 defaultselect="false" description="Return members of A matching the sequence of key values specified by parameter k" optionchar="k"/>
</options>
<params>
<P1 desc="k (Primary key, which will be written as a sequence if it is a multi-field primary key.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F220>
<F221 desc="Find the record(s) according to the specified primary key value(s) from a memory table." majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primay keys and return them as a record sequence; write multiple primary keys in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k(The primary key; write multiple keys as a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F221>
<F222 desc="Find the record(s) according to the specified primary key value(s) from a base table." majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primay keys and return them as a record sequence; write multiple primary keys in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k (The primary key; write multiple keys as a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Column name; retrieve all field if omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F222>
<F223 desc="F inverse cumulative distribution function." majortype="102" name="finv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="p(Probabilty, within the interval of (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v1(Numerator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v2(Denominator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F223>
<F224 desc="Convert a string or a numeric value  to a 64-bit double-precision floating-point number" majortype="102" name="float" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F224>
<F225 desc="Truncate the data at the specified positions, and reject all the remaining part if any" majortype="102" name="floor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (An integer to specify the position from which data is to be truncated; taken as 0 when it is omitted &gt;0: Move the decimal point to the right for nExp places &lt;0: Move the decimal point to the left for nExp places =0: Indicate the current decimal place.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F225>
<F226 desc="Get the names of fields of the table sequence according to the serial numbers of these fields." majortype="101" name="fname" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F226>
<F227 desc="Get the field names from records according to the serial numbers of these fields." majortype="101" name="fname" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F227>
<F228 desc="Get the serial number of a field in a table sequence." majortype="101" name="fno" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F228>
<F229 desc="Get the serial number of a field of a record in a table sequence." majortype="101" name="fno" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F229>
<F230 desc="Generate a formatted string in Java." majortype="101" name="format" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (The format parameter of the specified string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F230>
<F231 desc="Set the remote working directory/directories on the FTP server" majortype="102" name="ftp_cd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remotePath (The path name of a remote working directory; when it is omitted, the remote working directory on the FTP server is by default regarded as the root directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F231>
<F232 desc="Exit an FTP client program" majortype="102" name="ftp_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F232>
<F233 desc="List all directories and files under the current directory on an FTP server." majortype="102" name="ftp_dir" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Only list directories; parameter multiFiles is a wildcard-specified server file" optionchar="d"/>
<O2 defaultselect="false" description="List full paths of directories and files; parameter multiFiles is a wildcard-specified server file" optionchar="p"/>
<O3 defaultselect="false" description="Create new directories; parameter multiFiles is a file with fixed name" optionchar="m"/>
<O4 defaultselect="false" description="Delete empty directories; parameter multiFiles is a file with fixed name" optionchar="r"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="multiFiles(The path name of a remote working directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F233>
<F234 desc="Download a file from the FTP server." majortype="102" name="ftp_get" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile(A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F234>
<F235 desc="Download multiple files from a FTP server." majortype="102" name="ftp_mget" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiServerFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F235>
<F236 desc="Upload multiple files onto a FTP server." majortype="102" name="ftp_mput" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiLocalFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F236>
<F237 desc="Create an FTP client" majortype="102" name="ftp_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Start the FTP passive mode" optionchar="d"/>
</options>
<params>
<P1 desc="server (An FTP server’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (An FTP server’s port number, which is by default 21 and can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user (The username to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (The password to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F237>
<F238 desc="Upload a file to the FTP server." majortype="102" name="ftp_put" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile (A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F238>
<F239 desc="Call a subroutine" majortype="102" name="func" postfix="" returntype="102">
<options/>
<params>
<P1 desc="c (The master cell of a subroutine; it is usually the cell where the func is located )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (The parameter used in a subroutine; can be a numerical value, a sequence, or other types of value )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F239>
<F240 desc="Return the greatest common divisor" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression that will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F240>
<F241 desc="Return the greatest common divisor" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F241>
<F242 desc="Perform equi-grouping according one or more fields or expressions." majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted" optionchar="o"/>
<O2 defaultselect="false" description="Get the first record of each group to form a record sequence and return it (Please note that 1 is a number instead of a letter)" optionchar="1"/>
<O3 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @0 are mutually exclusive" optionchar="n"/>
<O4 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O5 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. This option is equivalent to A.group@o(a+=if(x,1,0)), in which a=0 and there is only one x" optionchar="i"/>
<O6 defaultselect="false" description="Discard the group over which the result of grouping expression x is null. Use it when there’s only one expression x" optionchar="0"/>
<O7 defaultselect="false" description="Perform a concatenation of sequences/records sequences after the grouping. It is equivalent to A.group(xi,…).conj()" optionchar="s"/>
<O8 defaultselect="false" description="Return a sequence of integer sequences, each of which contains the positions of members in each group in sequence A" optionchar="p"/>
<O9 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
</options>
<params>
<P1 desc="xi (Grouping expression. When grouping data by multiple fields or expressions, separate grouping expressions from each other by commas)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F242>
<F243 desc="Group a sequence and then perform aggregate operations." majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define a group. @n and @0 are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Discard the group over which the result of grouping expression x is null" optionchar="0"/>
<O6 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O7 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O8 defaultselect="false" description="Enables returning a result set containing aggregates only but not subgroups" optionchar="b"/>
</options>
<params>
<P1 desc="x (Grouping expression. If omitting x:F, aggregate the whole set without grouping; in this case ;must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate expression in which ~ is used to reference a group)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Names of summary fields in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F243>
<F244 desc="Group records in a channel by comparing each one with its neighbor(s) and return a channel." majortype="101" name="group" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With this option and with grouping expression x being a bool expression, start a new group if the result of x is true. Be sure there’s only one x in this case" optionchar="i"/>
</options>
<params>
<P1 desc="x  (Grouping expression. Use the comma to separate multiple grouping fields/expressions.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F244>
<F245 desc="Group cursor records by comparing only adjacent records and return the original cursor. " majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x is a bool expression. Begin a new group when a record makes it return true. In this case there should be only one x." optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it; here it is number 1, instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Return result as a table sequence on which an index can be directly created; by default, the function sorts the result" optionchar="t"/>
</options>
<params>
<P1 desc="x (Grouping expression. Multiple fields/expressions for grouping will be separated from each other with the comma.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F245>
<F246 desc="Group a cluster cursor by comparing each record with its next neighbor. " majortype="101" name="group" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F246>
<F247 desc="Group records of a given cursor by comparing each with its neighbours, peform aggregation over each group and return the original cursor." majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Enables returning a result set containing aggregates only but not subgroups" optionchar="b"/>
<O2 defaultselect="false" description="Cumulative aggregation" optionchar="s"/>
<O3 defaultselect="false" description="@q(x:F,…;x’:F’,…;…)Used when parameter cs is ordered by x,… and only fields after it need to be sorted; support in-memory sorting" optionchar="q"/>
<O4 defaultselect="false" description="@sq(x:F,…;x’:F’,…;…)Only sort without grouping when parameters y:G are absent, and perform cumulative aggregation when the parameters are present; @s works only when @q option is present" optionchar="sq"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (Aggregate expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (Aggregation field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F247>
<F248 desc="Generate a sequence for use in a data-input sheet." majortype="101" name="groupi" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Assume that the sequence is ordered, perform a merge by comparing each record with its next neighbor and won’t sort the result set" optionchar="o"/>
</options>
<params>
<P1 desc="Di (A data-input sheet’s dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F248>
<F249 desc="Group records in a cursor and push them respectively into a sequence of channels." majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F249>
<F250 desc="Group records in channel ch and push them respectively into a sequence of channels." majortype="101" name="groupn" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x (Gouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F250>
<F251 desc="Group records of a cursor and write the subset groups as a sequence of bin files." majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (A sequence of bin file objects)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F251>
<F252 desc="Group and aggregate a TSeq cumulatively." majortype="101" name="groups" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @o are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; can’t be used with @oi options. " optionchar="m"/>
<O6 defaultselect="false" description="Discard the group over which the result of grouping expression x is null" optionchar="0"/>
<O7 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O8 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O9 defaultselect="false" description="Enables returning a result set containing aggregates only but not subgroups" optionchar="b"/>
</options>
<params>
<P1 desc="x (Group expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (y is the function with which A is traversed. When y is an aggregate function, it only supports sum/count/max/min/top/avg/iterate/icount/median. When the function work with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted. When y isn’t an aggregate function, perform calculation over only the first record in each group.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Summary field name in the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F252>
<F253 desc="Group records in a channel." majortype="101" name="groups" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the resulting set by expression x; the option and @n are mutually exclusive" optionchar="u"/>
</options>
<params>
<P1 desc="x  (Grouping expression, by which an aggregation over the whole grouped set is performed if x:F is omitted. In that case the semicolon should not be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field names of the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (An aggregate function which only supports sum/count/max/min/top /avg/iterate; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n  (The maximum number of groups that can be divided. Stop execution if the number is exceeded. The parameter is defined for a situation where the number of groups to be divided is large yet indefinite. It doesn’t work with @n option.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F253>
<F254 desc="Group records in a cluster cursor, sort them by the grouping field and peform aggregation over each group and add each aggregate to the result set." majortype="102" name="groups" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Perform the group operation over data in every node and compose the result sets into a cluster memory table in the segmentation way of the cursor; suppport a cluster dimension table" optionchar="c"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top /avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F254>
<F255 desc="Group records in a cursor." majortype="101" name="groups" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first." optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a bool expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O6 defaultselect="false" description="Enables returning a result set containing aggregates only but not subgroups" optionchar="b"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n; it doesn’t work with @n option. Support a multicuror when this parameter is absent.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F255>
<F256 desc="Group records, in a channel and return a channel." majortype="101" name="groupx" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (An aggregate function which only supports sum/count/max/min/top /avg/iterate; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F256>
<F257 desc="Group the ordered records in a cursor and return result as a cursor. " majortype="101" name="groupx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. " optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the result set by parameter x; mutually exclusive with @n." optionchar="u"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
<O4 defaultselect="false" description="Enables returning a result set containing aggregates only but not subgroups" optionchar="b"/>
</options>
<params>
<P1 desc="x(Grouping expression.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(Result field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate function which only supports sum/count/max/min/top/ avg/iterate. When the function works with the iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G(Aggregate field name )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F257>
<F258 desc="Group records in a cluster cursor and return a synchronously segmented cursor." majortype="102" name="groupx" postfix="cs." returntype="102">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Resulting field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F258>
<F259 desc="Return a hash value" majortype="101" name="hash" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Data of any type)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer greater than 1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F259>
<F260 desc="Close a HBase connection." majortype="102" name="hbase_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F260>
<F261 desc="Compare data with the HBase-supplied comparator." majortype="102" name="hbase_cmp" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Match the current value with the prefix" optionchar="p"/>
<O2 defaultselect="false" description="Check if the current value is null but won’t perform matching" optionchar="n"/>
<O3 defaultselect="false" description="Use a regular expression to match table data" optionchar="r"/>
<O4 defaultselect="false" description="Use the threshold and table data, both of which are string type, to match up a string" optionchar="s"/>
<O5 defaultselect="false" description="Convet a string type or a date/time/datatime type parameter to a Long type one" optionchar="l"/>
<O6 defaultselect="false" description="Perform bit-level comparison using AND, OR and XOR operations" optionchar="b"/>
</options>
<params>
<P1 desc="str (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (Only use this parameter with @r option; its value can only be one of the following letters: i=case insensitive  (Case-insensitive)  m=multiline,     (^ and $ can match up a line break within a string) d=dotall,        (The dot symbol can match up a line break) u=unicode case,  (Case-insensitive in matching up Unicode characters ) q=canon_eq     (Consider same characters in different character encodings as equal)  x=unix_lines,    (Consider \n as a line break only) l=literal,        (Text mode) c=comments    (Comment mode) The value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Only use this parameter with @b option; its value can only be one of the following: AND, OR, XOR; the value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F261>
<F262 desc="Filter data with the HBase-supplied filter." majortype="102" name="hbase_filter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filterName (HBase filter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filterArg (Filter parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F262>
<F263 desc="Filter data with multiple filters." majortype="102" name="hbase_filterlist" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Every filter is independent in filtering data." optionchar="o"/>
</options>
<params>
<P1 desc="filterHandle (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F263>
<F264 desc="Query data in HBase database and return a single row." majortype="102" name="hbase_get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rowName (Row name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="column (Colum name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (‘filter:’ is a fixed format, and parameter f means filter handle; can be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="timeRange:[t1,t2] (‘timeRange:’ is a fixed format, and parameters t1 and t2 specify a range of timestamp; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
</params>
</F264>
<F265 desc="Create a HBase connection." majortype="102" name="hbase_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="zkUrl (Zookeeper connection information)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F265>
<F266 desc="Query a HBase database and return result as a cursor or a table sequence." majortype="102" name="hbase_scan" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="column (Column name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="Type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="rowPrefix:x (‘rowPrefix:’ is a fixed format; parameter x is the prefix of rowKey )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="startRow:startrow (‘startRow:’ is a fixed format; parameter startrow represents the starting row, which will be included in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
<P10 desc="stopRow:stoprow (‘stopRow:’ is a fixed format; parameter stoprow represents the ending row, which will be excluded in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P10>
<P11 desc="timeRange:[t1,t2] (‘timeRange:[,]’ is a fixed format; parameter t1 is the starting timestamp whose value will be retrieved, and parameter t2 is the ending timestamp whose value won’t be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P11>
</params>
</F266>
<F267 desc="Close the HDFS connection." majortype="102" name="hdfs_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="HdfsClient (An HDFS connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F267>
<F268 desc="Get the list of all files in a specified path." majortype="102" name="hdfs_dir" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List names of all directories in the specified path" optionchar="d"/>
<O2 defaultselect="false" description="List the full paths of all directories and files in the specified path" optionchar="p"/>
<O3 defaultselect="false" description="Create a directory; return true if the directory is created, otherwise return false" optionchar="m"/>
<O4 defaultselect="false" description="Delete a directory; return true if the operation is successful, otherwise return false" optionchar="r"/>
</options>
<params>
<P1 desc="hd (An hd connecton)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="path (A relative path within the path containing the HDFS file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F268>
<F269 desc="Download a local file to a specific position" majortype="102" name="hdfs_download" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Download all files in the specified folder to the local machine, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F269>
<F270 desc="Check whether there is a specified file or folder in HDFS and return a boolean value" majortype="102" name="hdfs_exists" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file/path(Hadoop file name/Hadoop path name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F270>
<F271 desc="Open a specified directory and return an HDFS file flow." majortype="102" name="hdfs_file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (The name of the to-be-loaded Hadoop file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (The charset embedded in JVM; by default it is the default value for a virtual machine)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F271>
<F272 desc="Connect to the HDFS file system and return a connection object." majortype="102" name="hdfs_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url(The URL format is scheme://authority/path. Scheme is the HDFS protocol name; authority is the host name; and path is a string of the file (or directory) path) " filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(A Hadoop user; default is root)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F272>
<F273 desc="Upload a local file to a specific position" majortype="102" name="hdfs_upload" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Upload all files in the specified folder to the specified path, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F273>
<F274 desc="Close a Hive database connection." majortype="102" name="hive_close" postfix="" returntype="102">
<options/>
<params/>
</F274>
<F275 desc="Query a Hive database and return the result as a cursor." majortype="102" name="hive_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F275>
<F276 desc="Execute Hive’s SQL-like queries. " majortype="102" name="hive_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, which supports Hive’s SQL-like queries such as create table, drop table, load data, insert into, insert owerwrite, and create view)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F276>
<F277 desc="Create a Hive database connection." majortype="102" name="hive_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="hdfsUserName  (HDFS file user name )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F277>
<F278 desc="uery a Hive database and return the result as a sequence." majortype="102" name="hive_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F278>
<F279 desc="Return the hyperlink string of a canvas" majortype="102" name="hlink" postfix="G." returntype="101">
<options/>
<params/>
</F279>
<F280 desc="Set or get the number of memory zone holding a specified task on the current node." majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i(An integer that represents memory zone number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="j(Task name; can be absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F280>
<F281 desc="Return a sequence of available nodes." majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n(The number of nodes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="j(Task name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F281>
<F282 desc="Get the hour from a specified time" majortype="102" name="hour" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp   (Date or standard datetime format string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F282>
<F283 desc="Get text data under a specified tag in an html file" majortype="101" name="htmlparse" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="tag(A tag in an html file; if the tag’s value is “table”, get all data under it)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="i(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="j(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F283>
<F284 desc="Package the returned result of URL as the file flow and return it." majortype="102" name="httpfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service in the URL string format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="post (A parameter submitted with POST method with a syntax like p1=v1&amp;p2=v2…. Can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="header(The header property can have multiple items, like headerName1:value1,headerName2:value2,... (the format is &quot;property&quot;:&quot;value&quot;,…); or can be omitted. The execution of .property() function over a returned file object will return the header property.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F284>
<F285 desc="Upload parameters and files to an URL using the HTTP protocol." majortype="101" name="httpupload" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service’s URL string format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F285>
<F286 desc="Count the number of distinct members in a sequence" majortype="101" name="icount" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove duplicates by comparing neighboring members" optionchar="o"/>
</options>
<params/>
</F286>
<F287 desc="Use index to filter an entity table or a multi-zone composite table according to the filtering condition." majortype="101" name="icursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Make sure the result set is ordered by the index and large result sets are supported " optionchar="s"/>
<O2 defaultselect="false" description="Handle multiple conditions joined up with &amp;&amp; from left to right while the default is handling them in an optimal order" optionchar="u"/>
</options>
<params>
<P1 desc="C (To-be-retrieved columns in the cluster table; get all columns when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w (Filtering condition, in which the filtering field for T must be the same as the indexing field; support &gt;, &gt;=, &lt;, &lt;=, == and contain in its syntax)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="I (Index name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F287>
<F288 desc="Use index to filter a cluster table according to the filtering condition." majortype="101" name="icursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Make the result set ordered by the index and support a big result set" optionchar="s"/>
</options>
<params>
<P1 desc="C(To-be-retrieved columns in the cluster table; get all columns when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition, in which the filtering field for T must be the same as the indexing field; support &gt;, &gt;=, &lt;, &lt;=, == and contain in its syntax)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="I(Index name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F288>
<F289 desc="Get distinct values from a sequence." majortype="101" name="id" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Without sorting, remove the repetitive neighboring members only" optionchar="o"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o" optionchar="u"/>
<O3 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
</options>
<params>
<P1 desc="xi (An expression; use ~ to represent x if the latter is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-retrieved distinct values counting from the beginning; return all values if it is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F289>
<F290 desc="Return a channel consisting of values of one or more fields." majortype="101" name="id" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; can’t be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F290>
<F291 desc="Return a sequence consisting of values of fields in a given cursor." majortype="101" name="id" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; return all values when omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F291>
<F292 desc="If a is true, then return true. Otherwise, return false" majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F292>
<F293 desc="If a is non-null and non-false, then return b; otherwise return c, which is null by default." majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b  (Value expression. If the result of a is true, then return the result of b)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (Value expresssion. If the result of a is false, then return the result of c)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F293>
<F294 desc="Calculate the boolean expression from left to right.if bool is true, then return the result of trueValue, and the computation will be terminated; If bool is false, then calculate the next bool. If none of the Boolean expression boolis true, and there is a default expression default, then return the result of default, otherwise return null." majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xk (Boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yk (Value expression. If the result of xk is true, then return its result.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Default value expression. If all the results of boolean expressions are false, then return the result of this expression.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F294>
<F295 desc="To judge if an object is a sequence" majortype="102" name="ifa" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x    (the object to be judged)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F295>
<F296 desc="Find whether the type of parameter is date or datetime" majortype="102" name="ifdate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F296>
<F297 desc="Get the first non-null member of a sequence.Equivalent to ifn(x1,…,xn)" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params/>
</F297>
<F298 desc="Compute x with each member of the sequence and return the first non-null member of the new sequence.Equivalent to A.(x).ifn()" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally ann expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F298>
<F299 desc="Find whether the parameter is of numeric data type." majortype="102" name="ifnumber" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F299>
<F300 desc="Find whether an object is a record." majortype="102" name="ifr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Any data object, for example a constant, an expression, a record, a record sequence, a sequence or a table sequence.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F300>
<F301 desc="Find whether the parameter is of string data type" majortype="102" name="ifstring" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp    (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F301>
<F302 desc="Judge if an object is a table sequence" majortype="102" name="ift" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x   (any object, for example: a constant, an expression, a record, a record sequence, a sequence or a  table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F302>
<F303 desc="Find whether the parameter is of time data type." majortype="102" name="iftime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp   (Data expression of any type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F303>
<F304 desc="Judge if a variable exists" majortype="102" name="ifv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="v (Parameter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F304>
<F305 desc="Close Informix database connection" majortype="101" name="ifx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F305>
<F306 desc="Create Informix database connection" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (The URL to connect to Informix server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fragfile (Fragmentation information file that records the fields and every field’s max and min values in each fragmented file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F306>
<F307 desc="Create Informix database connection" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="driver (Name of JDBC driver for connecting to Informix database; the format is com.informix.jdbc.IfxDriver)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F307>
<F308 desc="Query data in fragmented files from k1 to k2 using a SQL statement" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F308>
<F309 desc="List the fragmentation information of table table with cursors and search fragmented file k1 and fragmented file k2 according to the where condition. Parameter f is the table’s column name and parameter alias is the column’s another name. Parameter where can be omitted; parameter k2 will be omitted if parameter k1 is absent; search only framted file k1 when k2 is absent" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F309>
<F310 desc="Query data over the fragmented file specified by the parameter ifxCursor quries with a SQL statement; parameter f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F310>
<F311 desc="Query table table according to where condition over the fragmented file specified by parameter ifxCursor; parameter f is the table’s column name and parameter alias is its another name; f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
</params>
</F311>
<F312 desc="List the fragmentation information of a specified table with table sequences" majortype="101" name="ifx_listfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (The ifxconn object which holds the fragmentation information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F312>
<F313 desc="Save the fragmentation information file stored in the memory as a new file" majortype="101" name="ifx_savefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (A fragmentation information file, which can be the same file as fragfile or not.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F313>
<F314 desc="Set the fragmentation file of a specified table" majortype="101" name="ifx_setfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="fieldName (Fragmented field)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="min (The minimum value in a fragmented file; can be omitted and can have multiple values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F314>
<F315 desc="Extract fragmentation information from the database" majortype="101" name="ifx_takefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (The table being fragmented; can be omitted and can have multiple number of it)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F315>
<F316 desc="Fi is the retrieved fields. By default, all fields will be retrieved.s is the optional separator. By default, the separator is tab. The format of character string: Separate the records with space, and the fields with optional separators. The default separator is tab." majortype="101" name="import" postfix="S." returntype="101">
<options>
<O1 defaultselect="false" description="In f, take the record in the first row as the field name. If not using this option, then use _1, and _2,… as the field name." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O3 defaultselect="false" description="Won’t split strings and data will be imported as a table sequence consisting of strings of single field values; ignor the parameters" optionchar="s"/>
<O4 defaultselect="false" description="Return the result set as a sequence if it only contains one field" optionchar="i"/>
<O5 defaultselect="false" description="Remove the quotation marks, if any, from both ends of each data item, including those in the field names and handle the escape sequences; quotation marks not located at the ends are left alone" optionchar="q"/>
<O6 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O7 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Generate null if parameter Fi isn’t included in the imported strings; by default there will be an error report " optionchar="e"/>
<O9 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O10 defaultselect="false" description="Ignore a row whose number of columns don’t match the first row" optionchar="n"/>
<O11 defaultselect="false" description="In corporation with @d or @n, if a mismatch appears, throw an exception, terminate the execution and output the content of the problem record; error will be reported if parentheses or quotation marks does not match when @p option or @q option is present " optionchar="v"/>
<O12 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O13 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O14 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O15 defaultselect="false" description="Allow line continuation and put an escape character \ at the end the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi (Fields retrieved. By default, all fields will be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types include bool, int, long, float, decimal, number, string, date, time and datetime; data type of the first row will be used by default. It is the length of a serial byte when it is an integer.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt (Date\time format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F316>
<F317 desc="Read contents from a file and return them as a table sequence. " majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q and @m will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented. " optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field strings, including the field names, in the first place, and handle the escape sequences. " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in license file and configuration information. " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
</options>
<params/>
</F317>
<F318 desc="Read contents from a file and return them as a table sequence. " majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q and @m will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field stringsfrom both ends of each data item, including those in the field names, in the first place, and handle the escape sequences; quotation marks not located in the ends are left alone " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in configuration information. This option and @x option are mutual exclusive; errors may appear when @o option or parameters k:n are present " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="v"/>
<O14 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O15 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="f"/>
<O17 defaultselect="false" description="Allow line continuation where there is an escape character \ at the end of the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi      (Fields to be retrieved. All fields will be retrieved by default. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types include bool, int, long, float, decimal, string, date, time and datetime. Data type of the first row will be used by default. It is the length of a serial byte when it is an integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt(Date\time format)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="k (The segment number.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (The number of segments. Retrieve the whole file when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="s ( User-defined separator. The default separator is tab. When the parameter is omitted, the comma preceding it can be omitted, too. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F318>
<F319 desc="Read in records from an entity table and return them as a sequence, record sequence or table sequence." majortype="102" name="import" postfix="T." returntype="101">
<options/>
<params/>
</F319>
<F320 desc="Create an index table for the key of a table sequence." majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a multilevel tree-structure index and ignore parameter n if the TSeq’s key is for data ordering" optionchar="s"/>
<O2 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
</options>
<params>
<P1 desc="n (Index length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F320>
<F321 desc="Create an index for the key of a memory table." majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create the index with parallel processing" optionchar="m"/>
</options>
<params>
<P1 desc="n(The length of index)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F321>
<F322 desc="Create an index file for an entity table or a multi-zone composite table" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Auto-load and maintain the second-level index when only parameter I is present" optionchar="2"/>
<O2 defaultselect="false" description="Auto-load and maintain the third-level index when only parameter I is present" optionchar="3"/>
<O3 defaultselect="false" description="Close the index to release resources when only parameter I is present" optionchar="0"/>
<O4 defaultselect="false" description="Create a full-table index based on a certain column and support like(“*X*”) style search" optionchar="w"/>
</options>
<params>
<P1 desc="I(Index name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h(Index length)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="w(Filtering condition; retrieve the whose set if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(The field for which an index is created)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in an entity table; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F322>
<F323 desc="Return a positive infinity value; with a negative sign before the function, it will return a negative infinity value. " majortype="101" name="inf" postfix="" returntype="101">
<options/>
<params/>
</F323>
<F324 desc="Close InfluxDB connection." majortype="102" name="influx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F324>
<F325 desc="Insert one or more records to InfluxDB database." majortype="102" name="influx_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="string(Line protocol characters or line protocol arrays of characters. Data format should meet the requirements of InfluxDB line protocol; time stamp is represented in UTC or is in the format of yyyy-MM-ddTHH:mm:ss/yyyy-MM-ddTHH:mm:ssXXZ)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F325>
<F326 desc="Connect to InfluxDB." majortype="102" name="influx_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(Database connection URL)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="database(The database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="retentionPolicy(The retention plicy for defining how long InfluxDb needs to keep the data or which time period of data the database needs to store)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="username(The user name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="password(The password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F326>
<F327 desc="Query InfluxDB database." majortype="102" name="influx_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL query statement or database search statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F327>
<F328 desc="Insert the members of X before position k in A, and return A." majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence composed of the members to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F328>
<F329 desc="Insert member x before position k in A, and return A." majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k  (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (a member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F329>
<F330 desc="Insert an empty record before the position k in the T. If k is 0, then append it in the end and return the new T" majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F330>
<F331 desc="Insert a record into T before the position k where the value of Fi is xi and return the new T. When parameter k is omitted, we assume the table sequence T is already ordered by the key and insert records; if the key value has already existed, the function won’t perform the insertion." majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k      (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi      (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi     (The name of field where xi resides; without Fi, it will be the corresponding ith field.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F331>
<F332 desc="Insert multiple records into T before the position k where the value of Fi is xi and return the new T . The number of the records to be inserted is determined by the length of sequence A." majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences " optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k           (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A           (A sequence or an integer; If A is an integer, then it is equals to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi           (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi          (The name of field where xi resides; without Fi, it will be the corresponding ith field.))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F332>
<F333 desc="To obtain the integer part of a numeric value from a numeric string or a number, and convert its data type to 32-bit integer." majortype="102" name="int" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (an expression, the result of which must be a numeric string or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F333>
<F334 desc="Compute the interval between two datetime values" majortype="102" name="interval" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the years between two date time data" optionchar="y"/>
<O2 defaultselect="false" description="Compute the months between two date time data" optionchar="m"/>
<O3 defaultselect="false" description="Compute the seconds between two date time data" optionchar="s"/>
<O4 defaultselect="false" description="Compute the milliseconds between two date time data" optionchar="ms"/>
<O5 defaultselect="false" description="Compute the quarters between two date time data" optionchar="q"/>
<O6 defaultselect="false" description="Compute the timespan between two date time data and return Real valuer" optionchar="r"/>
<O7 defaultselect="false" description="Compute the weeks between two datetime values" optionchar="w"/>
<O8 defaultselect="false" description="Compute the number of Sundays between two datetime values according to a left-open interval" optionchar="7"/>
<O9 defaultselect="false" description="Compute the number of Mondays between two datetime values according to a left-open interval" optionchar="1"/>
</options>
<params>
<P1 desc="datetimeExp1     (The date expression whose value is a datetime or a string of standard datetime format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="datetimeExp2     (The date expression whose value is a datetime or a string of standard datetime format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F334>
<F335 desc="Adjust the order of members of a sequence." majortype="101" name="inv" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence, members of which is the rankings of A, so the number of its members is the same as that of A , and it is a unique n sequence (n=A.len()))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F335>
<F336 desc="Compute the sequence numbers of an integer’s members in another integer sequence." majortype="101" name="inv" postfix="p." returntype="101">
<options/>
<params>
<P1 desc="k (An integer, which is p.len() by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F336>
<F337 desc="Calculate the inverse of a square matrix. " majortype="101" name="inverse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F337>
<F338 desc="Call the static function of class in the package" majortype="102" name="invoke" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert the sequence type parameter or return value; can be performed recursively" optionchar="x"/>
</options>
<params>
<P1 desc="p (package path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (class name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f (static method name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ai (parameter)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F338>
<F339 desc="Check if a string is composed of letters" majortype="102" name="isalpha" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F339>
<F340 desc="Check if a string is composed of numbers." majortype="102" name="isdigit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F340>
<F341 desc="Compute x with each member of the sequence whose members are sequences, and then perform intersection operation between members of the new sequence" majortype="101" name="isect" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F341>
<F342 desc="Compute the intersection of all the member sequences of a sequence" majortype="101" name="isect " postfix="A." returntype="101">
<options/>
<params/>
</F342>
<F343 desc="Retrieve records from file f that is ordered by x field, according to the criterion that the values of x should be members of sequence A" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record when type matching error appears" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="A (A single value or a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F343>
<F344 desc="Rtrieve records from file f that is ordered by x field, according to the criterion that the values of x should fall in the interval [a:b]" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record when type matching error appears" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="a (Field value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Field value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F344>
<F345 desc="Check if a string is composed of lower case letters" majortype="102" name="islower" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F345>
<F346 desc="Define transaction isolation level for the connection according to the option and return the original level" majortype="102" name="isolate" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Correspond respectively to NONE" optionchar="n"/>
<O2 defaultselect="false" description="Correspond respectively to READ_COMMITTED" optionchar="c"/>
<O3 defaultselect="false" description="Correspond respectively to READ_UNCOMMITTED" optionchar="u"/>
<O4 defaultselect="false" description="Correspond respectively to REPEATABLE_READ" optionchar="r"/>
<O5 defaultselect="false" description="Correspond respectively to SERIALIZABLE" optionchar="s"/>
</options>
<params/>
</F346>
<F347 desc="Check if a string is composed of upper case letters" majortype="102" name="isupper" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F347>
<F348 desc="Perform interative loop on a record sequence and return the result of the last calculation of a given expression." majortype="101" name="iterate" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (A boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F348>
<F349 desc="Perform interative loop on record sequences in a channel and return the result of the last calculation of a given expression" majortype="101" name="iterate" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F349>
<F350 desc="Perform interative loop on record sequences in a cursor and return the result of the last calculation of a given expression" majortype="101" name="iterate" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F350>
<F351 desc="An iterative loop for calculating an expression." majortype="102" name="iterate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression containing ~~)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F351>
<F352 desc="Join multiple sequences together." majortype="102" name="join" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matches are found, then correspond to the null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Please note that this is the number &quot;1&quot; instead of the letter &quot;l&quot;" optionchar="l"/>
<O3 defaultselect="false" description="Supporse if all Ai are in order for xj, then use merge operation instead." optionchar="m"/>
<O4 defaultselect="false" description="Perform a join according to positions while ignoring parameter xj" optionchar="p"/>
<O5 defaultselect="false" description="If field values of the sequences to be joined are records, the joining values will be unfolded" optionchar="x"/>
<O6 defaultselect="false" description="Used only to filter A1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O7 defaultselect="false" description="Used only to filter A1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="Ai (Sequences or record sequences to be joined)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name of the resulting table sequence)" filtertype="0" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Relational field/ expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F352>
<F353 desc="A foreign-key-style join between table sequences/record sequences, or a table sequence and a record sequence." majortype="101" name="join" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default a non-matching record will be represented by null." optionchar="i"/>
<O2 defaultselect="false" description="Use the record as the value of F field to generate a new record; here expression x can be represented by ~. " optionchar="o"/>
<O3 defaultselect="false" description="If parameter x:F is absent, delete the records matching the foreign key and perform the filtering operation only over table sequence/record sequence A" optionchar="d"/>
<O4 defaultselect="false" description="When parameter x is ~, record the relationship between parameter F and parameter C to identify the potentially associative foreign key" optionchar="k"/>
<O5 defaultselect="false" description="Enable a merge join when A is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (A’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (Table sequence/record sequence/memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression, which can be represented by ~ and #; the pound sign # represents the sequence number of a record in T; record the sequence number as 0 if a record doesn’t exist in T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F353>
<F354 desc="A foreign-key-style join between a channel and a record sequence." majortype="101" name="join" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the whole record if the foreign key can’t be matched; by default make it null." optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…),Generate a new record by introducing the original record as a new field; field expression x can be represented by ~." optionchar="o"/>
</options>
<params>
<P1 desc="C  (Foreign key of a given channel; use comma to separate a composite key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T  (Table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K  (Key of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x  (A field expression of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F  (Name of the field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F354>
<F355 desc="A foreign-key-style join between a cursor and a table sequence/record sequence.  " majortype="102" name="join" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default a non-matching record will be represented by null" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Use the record as the value of F field to generate a new record; here expression x can be represented by ~, which is T’s record" optionchar="o"/>
<O3 defaultselect="false" description="If parameters x:F are absent, only perform a filtering over the cursor by deleting its records where the foreign key is matched " optionchar="d"/>
<O4 defaultselect="false" description="Enable a merge join when A is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (Cursor cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (A table sequence/A record sequence )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F355>
<F356 desc="A foreign-key-style join between a cluster cursor and a record sequence." majortype="101" name="join" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="With a distributed cluster table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="C(cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K(T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x(T’s field expression )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(Name of T’s field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F356>
<F357 desc="A foreign-key-style join beween an in-memory table and a table sequence or two in-memory tables" majortype="101" name="join" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete records of T that cannot match the foreign key, and by default, will record corresponding values as nulls. When parameters x:F are absent, just perform the fileting on Ai" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…) Use the original records of Ai as a new field F to generate new records; here x is equivalent to ~" optionchar="o"/>
<O3 defaultselect="false" description="Delete records of T that match the foreign key when parameters x:F are absent, which is equivalent to performing fileting on Ai" optionchar="d"/>
<O4 defaultselect="false" description="When x is represented by ~, record the correspondence relationship between F and C,…in the result set to identify the foreign key for a pre-join" optionchar="k"/>
</options>
<params>
<P1 desc="C(T’s foreign key; use colon to separate multiple fields of a composite foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(A table sequence or an in-memory table)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="K(Ai’s key)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="x(Expression of an Ai’s field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="F(Field name of expression x)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F357>
<F358 desc="Join table sequences retrieved from a series of cursors." majortype="102" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matched value is found, then it corresponds to null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Note that it is the number “1”, instead of letter “l”. " optionchar="1"/>
<O3 defaultselect="false" description="Perform a join according to positions, while ignoring the parameter xj" optionchar="p"/>
<O4 defaultselect="false" description="Used only to filter A1 cs1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O5 defaultselect="false" description="Used only to filter cs1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="csi (Cursors/table sequences/cluster cursors being joined.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of result TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Join field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F358>
<F359 desc="Join up synchronously segmented cluser cursors." majortype="101" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join; use null to correspond when there is no matching value" optionchar="f"/>
<O2 defaultselect="false" description="Left join; the option is number 1 instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Join by positions; ignore parameter xj" optionchar="p"/>
</options>
<params>
<P1 desc="csi (To-be-joined cluster cursors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The resulting field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Joining field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F359>
<F360 desc="Join up a cursor and a segmentable bin file by the foreign key." majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence " optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the cursor is ordered by the first foreign key field; can work with @q option " optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
<O7 defaultselect="false" description="Perform a merge join when cs is ordered by C and f is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A bin file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The bin file’s key; it is treated as row number when written as # )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of f)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F360>
<F361 desc="Join up a cursor and an entity table by the foreign key." majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence cs Speed up the join when the cursor contains relatively small amount of data or is a sequence" optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the cursor is ordered by the first foreign key field.When the cursor is ordered by the first field of its foreign key, use it to speed up the join; can work with @q" optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P1>
<P2 desc="T (An entity table/composite table cursor)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The entity table’s key; it is treated as row number when written as #)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F361>
<F362 desc="Join up a channel and a bin file or an entity table by the foreign key." majortype="102" name="joinx" postfix="ch." returntype="102">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the channel contains a relatively small amount of data or it is a sequence " optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the channel is ordered by the first foreign key field; can work with @q" optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the channel" optionchar="u"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F362>
<F363 desc="Parse a string, a record or a table sequence in JSON format." majortype="102" name="json" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Treat parameter x as an expression and calculate its result" optionchar="v"/>
</options>
<params>
<P1 desc="x(A JSON string/record/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F363>
<F364 desc="Generate a serial byte with a specified number of bytes" majortype="102" name="k" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (The length of bytes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F364>
<F365 desc="Generate a serial byte with a specified number of bytes" majortype="101" name="k" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ni (Byte value)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F365>
<F366 desc="Close a Consumer connection" majortype="101" name="kafka_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F366>
<F367 desc="Commit the current consumer offset position" majortype="101" name="kafka_commit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Asynchronous commit" optionchar="a"/>
</options>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F367>
<F368 desc="Connect to Kafka server" majortype="102" name="kafka_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="For the use of clustering and related operations" optionchar="c"/>
</options>
<params>
<P1 desc="filename/fileObject(The attribute parameter file with the extension .properties, which contains the send key, value encoding and message decoding; all of them should correspond to each other one by one/A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic(Query one or more specified topics)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partitionSize(The number of zones on a topic, which can be absent and is valid only in the context of a cluster)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F368>
<F369 desc="Return records in a Consumer topic as a table sequence" majortype="101" name="kafka_poll" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A Consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="timeout (The interval of consumer poll loop; default is 1000ms)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partition(A Kafka topic partition in the cluster mode, which is an integer or an array of integers)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F369>
<F370 desc="A producer publishes messages to topics" majortype="102" name="kafka_send" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="partition(The index number of a topic partition in a cluster, which is an integer beginning from 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(The key word of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="value(Value of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F370>
<F371 desc="Connect to Kafka server" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="prop:value (The property parameter Properties, which will be input in the form of k:v and which can include multiple property parameters; refer to Kaka documents to learn more about this)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ValueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F371>
<F372 desc="Connect to Kafka server" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filename (The property parameter file suffixed with .properties)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fileObject  (A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="valueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F372>
<F373 desc="Get the primary key value of a record." majortype="101" name="key" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Key)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F373>
<F374 desc="Set a key for a table sequence." majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Set the last parameter KT as the time key, and make all other parameters the basic keys" optionchar="t"/>
</options>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F374>
<F375 desc="Define the key(s) for a memory table." majortype="101" name="keys" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F375>
<F376 desc="Create an index over a primary key when the latter is set" majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a hash index" optionchar="i"/>
<O2 defaultselect="false" description="Create a serial byte index for a serial byte primary key; omit parameter n when using this option" optionchar="s"/>
<O3 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
</options>
<params>
<P1 desc="Ki(Primary key, which can be one or multiple; delete all keys of a memory table when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(An integer greater than 1, which is length of the hash table; its default lenght is the table length. Will be omitted when creating a serial byte index with @s option)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F376>
<F377 desc="An external libaray function that builds models and performs predictions using the Lasso regression method." majortype="102" name="lasso" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F377>
<F378 desc="Return the least common multiple" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The expression, which will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F378>
<F379 desc="Return the least common multiple" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F379>
<F380 desc="Get the substring from the left of a string" majortype="102" name="left" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (Get the source string of the substring)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n   (Get the length of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F380>
<F381 desc="Get the length of a sequence" majortype="101" name="len" postfix="A." returntype="101">
<options/>
<params/>
</F381>
<F382 desc="Get the length of a serial byte" majortype="101" name="len" postfix="k." returntype="101">
<options/>
<params/>
</F382>
<F383 desc="Get the number of records in a memory table." majortype="101" name="len" postfix="T." returntype="101">
<options/>
<params/>
</F383>
<F384 desc="Compute the length of string" majortype="102" name="len" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String for which you want to compute the length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Charset; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F384>
<F385 desc="Compute the logarithm with 10 as its base" majortype="102" name="lg" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to compute the logarithm with 10 as its base)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F385>
<F386 desc="Find if a string matches a format string" majortype="102" name="like" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Indicate not case-sensitive during matching, otherwise, case sensitive by default" optionchar="c"/>
</options>
<params>
<P1 desc="stringExp      (Expression of character sting) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp     (Expression of format string) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F386>
<F387 desc="Perform linear fitting using the least squares method." majortype="101" name="linefit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable returning a vector since parameter Y is a vector" optionchar="1"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F387>
<F388 desc="Compute the natural logarithm of parameters" majortype="102" name="ln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the natural logarithm)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F388>
<F389 desc="Use a synchronization lock." majortype="101" name="lock" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Unlock the restriction" optionchar="n"/>
</options>
<params>
<P1 desc="n (Lock name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Timeout (in millisecond); waiting to be locked if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F389>
<F390 desc="Convert the value of a string  to a 64-bit long integer." majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (The string expression you want to return as a long integer.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F390>
<F391 desc="Convert the value of  a number to a 64-bit long integer." majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp(The number you want to return as a long integer. If the number contains decimal fractions, the fractional part will be truncated. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F391>
<F392 desc="Convert a date to a 64-bit long integer" majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp(Date type expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F392>
<F393 desc="Convert all characters to lower case" majortype="102" name="lower" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="A quoted string won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s      (Strings you want to convert to the lower case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F393>
<F394 desc="Get members at specified positions.-n&lt;=i&lt;=n and i is not equal to 0; For 1≤i≤n, it indicates to get the ith member; For -n≤i≤-1,  it indicates to get the ith member from the last " majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F394>
<F395 desc="P is a non-zero n-integer sequence " majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P (A non-zero n-integer sequence) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F395>
<F396 desc="Get members of a sequence at specified positions to form a new sequence." majortype="101" name="m" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="a (Integer; 1 by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="c (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d (Integer; 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="e (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F396>
<F397 desc="Calculate the mean absolute error between two vectors." majortype="101" name="mae" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F397>
<F398 desc="Compute the maximum value of all the non-null members in a sequence.Equivalent to max(x1,…,xn)" majortype="101" name="max" postfix="A." returntype="101">
<options/>
<params/>
</F398>
<F399 desc="Compute x with each member of the sequence and then compute the maximum value of the members of the new sequence,Equivalent to A.(x).max()" majortype="102" name="max" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F399>
<F400 desc="Pick out the maximum member of a sequence" majortype="101" name="maxp" postfix="A." returntype="101">
<options>
<O1 defaultselect="true" description="Return the first member that fulfills the conditions" optionchar="1"/>
<O2 defaultselect="false" description="Return all the members that fulfill the conditions. By default, it is @1" optionchar="a"/>
<O3 defaultselect="false" description="Search the members from back to front" optionchar="z"/>
</options>
<params>
<P1 desc="x  (The expression to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F400>
<F401 desc="Perform cumulative sum on a matrix or a multidimensional matrix." majortype="102" name="mcumsum" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A matix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F401>
<F402 desc="Generate a multicursor based on a sequence of cursors." majortype="101" name="mcursor" postfix="CS." returntype="101">
<options/>
<params/>
</F402>
<F403 desc="Generate a multicursor based on one cursor." majortype="101" name="mcursor" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n  (An integer, which should be no greater than the number of parallel tasks set in TOOL&gt;OPTION.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F403>
<F404 desc="Return a string’s MD5 signature. " majortype="101" name="md5" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F404>
<F405 desc="Divide a sequence into multiple segments and return the specified bordering member(s)" majortype="101" name="median" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (The kth segment (1=&lt;k&lt;=n); return the bordering members of between every two segments as sequence when k is absent )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-divided segments, which is greater than 1 and whose default is 2; can be omitted when parmeter k is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F405>
<F406 desc="Divide a sequence into multiple segments and return the specified bordering member(s)." majortype="102" name="median" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="k (The kth segment (1=&lt;k&lt;=n); return the bordering members of between every two segments as sequence when k is absent )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-divided segments, which is greater than 1 and whose default is 2; can be omitted when parmeter k is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F406>
<F407 desc="Generate an in-memory table from a cursor." majortype="102" name="memory" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field, which must be ordered; when the first field is already segmented and the to-be-retrieved field, the result table will inherit the segmentation" optionchar="p"/>
</options>
<params>
<P1 desc="K (The key; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F407>
<F408 desc="Generate a cluster memory table from a cluster cursor." majortype="101" name="memory" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="K(The key; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F408>
<F409 desc="Generate a cluster memory table from a local memory table" majortype="101" name="memory" postfix="" returntype="101">
<options/>
<params>
<P1 desc="h (Node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="V (A memory table’s global variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F409>
<F410 desc="Generate a memory table from an entity table." majortype="101" name="memory" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field, which must be ordered; when the first field is already segmented and the to-be-retrieved field, the result table will inherit the segmentation" optionchar="p"/>
</options>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F410>
<F411 desc="Generate a cluster memory table from a cluster entity table." majortype="101" name="memory" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F411>
<F412 desc="Merge multiple table sequences/record sequences." majortype="101" name="merge" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove the duplicates from the table sequence/record sequence generated from unioning members of A(i)s in certain order; records with same xi have same corresponding members of A(i)" optionchar="u"/>
<O2 defaultselect="false" description="Return a table sequence/record sequence composed of the common members of A(i)s" optionchar="i"/>
<O3 defaultselect="false" description="Generate a new table sequence/record sequence by removing members of A(2)&amp;…A(n) from A(1)." optionchar="d"/>
<O4 defaultselect="false" description="Do not assume that A(i) is already sorted by [xi,…]" optionchar="o"/>
<O5 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
<O6 defaultselect="false" description="Remove common members of A(i) and union the other members to generate a new table sequence/sequence" optionchar="x"/>
</options>
<params>
<P1 desc="xi  (A field of A(i). If performing merge by multiple fields, use the comma to separate them, for example, x1,x2... )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F412>
<F413 desc="Merge data of the member cursors of a cursor/composite table cursor sequence. " majortype="101" name="mergex" postfix="CS." returntype="101">
<options>
<O1 defaultselect="false" description="Combine members of CS, the sequence of cursors, in a certain order to create a new cursor. All duplicate members are included by default." optionchar="u"/>
<O2 defaultselect="false" description="Return a cursor composed of common members of CS, the sequence of cursors." optionchar="i"/>
<O3 defaultselect="false" description="The new cursor created by removing members of CS2&amp;…CSn from CS1." optionchar="d"/>
<O4 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
<O5 defaultselect="false" description="Only merge distinct records in member cursors" optionchar="x"/>
</options>
<params>
<P1 desc="xi (An expression. If perfoming merge by multiple fields, use comma to separate them, for example, x1,x2....)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F413>
<F414 desc="Merge all parts of a cluster cursor into a local ordinary cursor." majortype="101" name="mergex" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression; use the comma to separate multiple expressions if it is a merge by multiple fields, like x1,x2...)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F414>
<F415 desc="Merge multicursors into an ordinary cursor." majortype="101" name="mergex" postfix="mcs." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression; use the comma to separate multiple expressions if it is a merge by multiple fields, like x1,x2...)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F415>
<F416 desc="Search for positions of non-zero members in a vector or matrix." majortype="102" name="mfind" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F416>
<F417 desc="Return the substring of a string " majortype="102" name="mid" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s  (Source string from which to get the substring )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="start (Get the starting position of substring )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="len (Get the length of substring. By default, the length will be counted from the starting character to the  end of the source string) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F417>
<F418 desc="Get the millisecond from a specified datetime value." majortype="102" name="millisecond" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F418>
<F419 desc="Compute the minimum value of all the non-null members in a sequence.Equivalent to min(x1,…,xn)" majortype="101" name="min" postfix="A." returntype="101">
<options/>
<params/>
</F419>
<F420 desc="Compute x with each member of the sequence and then compute the minimum value of the members of the new sequence" majortype="101" name="min" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F420>
<F421 desc="Get the member that makes the minimum value for the expression" majortype="101" name="minp" postfix="A." returntype="101">
<options>
<O1 defaultselect="true" description="Return the first member that fulfills the conditions" optionchar="1"/>
<O2 defaultselect="false" description="Return all the members that fulfill the conditions. By default, it is @1" optionchar="a"/>
<O3 defaultselect="false" description="Search the members from back to front " optionchar="z"/>
</options>
<params>
<P1 desc="x (the expression to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F421>
<F422 desc="Get the minute from a datetime value." majortype="102" name="minute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F422>
<F423 desc="Calculate the mean value within a matrix or a multidimensional marix." majortype="102" name="mmean" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate the mean on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F423>
<F424 desc="Normalize a matrix or a multidimensional matrix, during which the center value is 0 and the standard deviation is 1." majortype="102" name="mnorm" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Handle the normalization using a statistical method where n-1 is the divisor" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F424>
<F425 desc="Get the most frequently appearing members from a sequence or a table sequence." majortype="101" name="mode" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Fields of the table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F425>
<F426 desc="Modify the field values of a record" majortype="101" name="modify" postfix="r." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="xi  (Modification expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Name of the field to be modified. The ith field in r will be modified if Fi isn’t supplied.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F426>
<F427 desc="Modify the kth record, which is equal to T(k).modify(xi:Fi,…)" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)    Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)    Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k   (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi   (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi   (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F427>
<F428 desc="Modify the records from the kth record to the (k+|A|-1)th record" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)   Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)   Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A (A sequence or an integer; If A is an integer, then it is equal to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F428>
<F429 desc="Assign x to the kth member of sequence A" majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (a member value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F429>
<F430 desc="Assign members of X to members of A in order from the kth position to the (k+|X|-1)th position " majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F430>
<F431 desc="Close conncetion to MongoDB database" majortype="101" name="mongo_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd (MongoDB connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F431>
<F432 desc="Insert data to a MongoDB database." majortype="102" name="mongo_insert" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection(A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="T(A table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F432>
<F433 desc="Insert data to a MongoDB database." majortype="102" name="mongo_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd (A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection (A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F433>
<F434 desc="Connect to the MongoDB server." majortype="101" name="mongo_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (mongodb://[username:password@]host1[:port1]       [,host2[:port2],...[,hostN[:portN]]]/database[?options])" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F434>
<F435 desc="Query and manipulate the databsase and return result value." majortype="102" name="mongo_shell" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Close the MongoDB connection automatically closes when the execution finishes; if the returned result is a cursor, disconnect from the database as the cursor closes." optionchar="x"/>
<O2 defaultselect="false" description="Return a table sequence" optionchar="d"/>
<O3 defaultselect="false" description="Return a cursor; should be used together with @d option, otherwise it is invalid" optionchar="c"/>
</options>
<params>
<P1 desc="fd (MongoDB connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An MongoDB function, which supports find, count, distinct and aggregate and follows the MongoDB syntax)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F435>
<F436 desc="Get the month from a specified date/datetime value." majortype="102" name="month" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a 6-digit number if there is a year part in the parameter" optionchar="y"/>
</options>
<params>
<P1 desc="dateExp (An expression whose result is a date or a datetime value of standard format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F436>
<F437 desc="Move, delete, or rename a file." majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force an execution of the function if the target file already exists. Without the option you can’t force an execution. Delete the target file if parameter path is absent." optionchar="y"/>
<O2 defaultselect="false" description="Copy the file. If the target file name is the same as that of the specified file to which it will be moved, the copy fails." optionchar="c"/>
<O3 defaultselect="false" description="path is relative to the main directory when it is a relative path; default is relative to fn’s parent directory" optionchar="p"/>
</options>
<params>
<P1 desc="fn(A file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="path(The path (with file name) along which the file is moved, or a file name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F437>
<F438 desc="Move a file from a node to another" majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force moving to overwerite a namesake file while default is failure, and deletion when path is null;" optionchar="y"/>
<O2 defaultselect="false" description="Copy the file, and the copy fails if there is already a namesake file" optionchar="c"/>
</options>
<params>
<P1 desc="fn(A file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer that can be omitted, or a zone table number when fn is a homo-name files group; can )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="path(A path (that contains file name) to which a file is moved, or a file name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="hs(A node or a node sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F438>
<F439 desc="Calculate the standard error of the mean between two vectors." majortype="101" name="mse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F439>
<F440 desc="Calculate the standard deviation on a matrix or a multidimensional marix." majortype="102" name="mstd" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Perform the calculation using a statistical method, during which the n-1 is the divisor" optionchar="s"/>
<O2 defaultselect="false" description="Calculate the standard deviation on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F440>
<F441 desc="Calculate sum on a matrix or a multidimensional marix." majortype="102" name="msum" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate sum on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F441>
<F442 desc="Calculate the product of two matrices or vectors." majortype="101" name="mul" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F442>
<F443 desc="Return a file’s path relative to the main directory." majortype="2" name="name" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return a full path" optionchar="p"/>
</options>
<params/>
</F443>
<F444 desc="Generate a new table sequence/record sequence, whose field values are computed from the field values of a table sequence/record sequence." majortype="101" name="new" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set." optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if the result of expression xi is null." optionchar="i"/>
</options>
<params>
<P1 desc="xi (Expression whose result is the field value. If omitted, field values will be null and :Fi must not be omitted at the same time. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name. If omitting it, then use the identifier parsed from the xi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F444>
<F445 desc="Return the channel with newly-computed field values for its records." majortype="101" name="new" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate the corresponding record when the result of computing expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F445>
<F446 desc="Return a cursor with newly-computed field values for its records." majortype="101" name="new" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if the result of expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F446>
<F447 desc="Get values of specified field(s)  from a composite table according to key values in a table sequence, record sequence or a cursor and return result as a table sequence or a cursor." majortype="101" name="new" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="When A/cs is the main table and T is the subtable, return values that match the former’s key; in this case same records as those in T will be fetched. By default return values that match T’s key and aggregate is allowed." optionchar="r"/>
<O2 defaultselect="false" description="Match existing fields of A/cs with T’s dimension/key" optionchar="z"/>
</options>
<params>
<P1 desc="A/cs (A table sequence/cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition; separate multiple conditions, which should be met at the same time, by comma(s))" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F447>
<F448 desc="Retrieve specified fields from a cluster composite table according to key values of a cluster table or a cluster cursor and return a cluster cursor." majortype="101" name="new" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="A/cs (A cluster table cluster cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition; separate multiple conditions, which should be met at the same time, by comma(s))" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F448>
<F449 desc="Compute an expression on a specified field of a pseudo table, assign results to the field and return a new pseudo table" majortype="101" name="new" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate the corresponding record when parameter is present but its result of computing a record is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi(An expression whose values are assigned to a specific field; record the field values as null when the parameter is absent, and in this case, : Fi after it should be kept; when it is the number sign #, locate a value by the sequence number of its corresponding field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Field names in the result psudo table; use the identifiers parsed from expression xi when it is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F449>
<F450 desc="Compute field values based on a table sequence/record sequence, and concatenate them to generate a new one." majortype="101" name="news" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when record sequence X is empty" optionchar="1"/>
</options>
<params>
<P1 desc="X (A record sequence/integer; equivalent to to(X) if it is an integer, meaning the frequency of inserting each record in A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Expression, whose results will be field values; the sign ~ used in the parameter references data from record sequence X instead of A. The sign # is used to represent a field with a sequence number  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Field name of the new table sequence/record sequence; when omitted, it will be automatically identified  )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F450>
<F451 desc="Get new values for the fields of records in a channel and update them into the channel." majortype="101" name="news" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="X  (Record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi  (Expression, whose results will be field values; the sign ~ used in the parameter references data from X instead of A. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi  (Field name in the given channel; will be automatically identified if the parameter is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F451>
<F452 desc="Compute new cursor field values to update them into the original cursor." majortype="101" name="news" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when record sequence X is empty" optionchar="1"/>
</options>
<params>
<P1 desc="X (Record sequence )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Filed name of the new cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F452>
<F453 desc="Get values of specified field(s) in a composite table according to key values in a table sequence or a cursor, concatenate them and return result as a table sequence or a cursor." majortype="102" name="news" postfix="T." returntype="102">
<options>
<O1 defaultselect="false" description="Match existing fields of A/cs with T’s dimension/key" optionchar="z"/>
</options>
<params>
<P1 desc="A/cs(A table sequence/cursor/composite table cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Field value)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and they must be all met at the same time)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F453>
<F454 desc="Retrieve specified fields from a pseudo table by matching its records with key values another pseudo table, a table sequence, or a cursor, and join them onto the latter to generate a new pseudo table" majortype="101" name="news" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T’A/cs(A pseudo table/table sequence/cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Field values)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="wi(Filtering condition separated by commas and where the relationship between them is AND)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F454>
<F455 desc="Find records in a recursive way where the foreign key values reference a specified record." majortype="101" name="nodes" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Make the function return leaf-level nodes " optionchar="d"/>
<O2 defaultselect="false" description="Make the function return all child nodes and their level relative to the root node. " optionchar="p"/>
</options>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F455>
<F456 desc="Normalize a matrix or a vector" majortype="102" name="norm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable subtracting the mean from each row only without keeping lengths same;the mean value after normalization is 0. The parameter is invalid when parameter A is a matrix" optionchar="0"/>
<O2 defaultselect="false" description="0-1 normalization; mean value after normalization is 0, and standard deviation is 1" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F456>
<F457 desc="An inverse normal cumulative distribution function." majortype="102" name="norminv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability,  within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mu(The mean value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="sigma(The standard deviation, which is a positive number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F457>
<F458 desc="On integers, perform bitwise NOT operation to get the logical negation on each bit" majortype="102" name="not" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (The numeric expression for which you want to find the logical negation on each bit)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F458>
<F459 desc="Get the current system date time" majortype="102" name="now" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the date part only, date type" optionchar="d"/>
<O2 defaultselect="false" description="Return the time part only, time type" optionchar="t"/>
<O3 defaultselect="false" description="Acurrate to minute" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to second" optionchar="s"/>
</options>
<params/>
</F459>
<F460 desc="Convert a string to a number." majortype="101" name="number" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (A string expression, the result of which is a numeric value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A format string;can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F460>
<F461 desc="Get the first non-null member that isn’t double quoted from an integer sequence." majortype="101" name="nvl" postfix="A." returntype="101">
<options/>
<params/>
</F461>
<F462 desc="Close connection to a multidimensional database." majortype="102" name="olap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="conn (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F462>
<F463 desc="Establish connection to multidimensional database." majortype="101" name="olap_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (Address of the server on which a multidimensional database runs)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="catalog (The multidimensional database name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="user (User name for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (Password for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F463>
<F464 desc="Query data in a multidimensional database and return the result." majortype="101" name="olap_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="conn (The connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdx (A multidimensional database query that allows one or two axes)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F464>
<F465 desc="Create a multidimensional matrix where all the elements are1." majortype="102" name="ones" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F465>
<F466 desc="Open a composite table’s base table" majortype="101" name="open" postfix="f." returntype="101">
<options/>
<params/>
</F466>
<F467 desc="Generate a cluster table from a cluster file." majortype="2" name="open" postfix="" returntype="101">
<options/>
<params/>
</F467>
<F468 desc="Perform bitwise OR operation on integers" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression based on which you perform the bitwise OR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F468>
<F469 desc="Perform bitwise OR operation on integers" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F469>
<F470 desc="Print out data to console" majortype="102" name="output" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Print out the print data along with current time and place the current time before the print data " optionchar="t"/>
<O2 defaultselect="false" description="Won’t create a new line using carriage return after the current info is output, which means info of the next cell will be printed on same line of that of the current one" optionchar="s"/>
</options>
<params>
<P1 desc="x  (Export parameters separated with comma)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F470>
<F471 desc="Get serial numbers of the members at the specified positions.-n≤i≤n and i is not equal to 0; For 1≤i≤n, it indicates to get the serial number of the ith  member; For -n≤i≤-1, it indicates to get the serial number of the ith member from the last. " majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F471>
<F472 desc="Get serial numbers of the members at the specified positions.P is the n integer sequence whose length is m, the member values of which should be larger  than -n and less than n, but not equal to 0. " majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P(the n integer sequence whose length is m)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F472>
<F473 desc="Pad another character string ahead of the character string until reaching the specified length." majortype="102" name="pad" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Pad another character string on the right of the character string" optionchar="r"/>
</options>
<params>
<P1 desc="s (Character string expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (Character string expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="l (Character string whose result is the numeric value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F473>
<F474 desc="Add members of a sequence to another one until the latter reaches certain length." majortype="101" name="pad" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add members before the existing members of sequence A; by default the additions will be placed at its end." optionchar="l"/>
<O2 defaultselect="false" description="If the length of sequence A is the multiple of n, do not perform the adding action. If the length of A isn’t the multiple of n, add members to A until its length is the multiple of n; the number of additions – which are members of sequence x – need to be added after the existing members can be calculated with the formula – m=n-A.len()%n. " optionchar="m"/>
</options>
<params>
<P1 desc="x (A single value or a sequence; with a sequence, add its members sequentially to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F474>
<F475 desc="Parse a string into the corresponding data type" majortype="102" name="parse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove quotes of the string before starting an escape sequence including the escape character and unicode. By default the string will not be escaped." optionchar="e"/>
<O2 defaultselect="false" description="Retrieve a substring with enough length starting from the left side and parse it, while ignoring the unparsable rest. Note that the string needs to begin with the numeric value." optionchar="n"/>
<O3 defaultselect="false" description="If a string starts with the squotation marks, parse it until the next quotation marks appears and leave the rest of the string alone, and return a string." optionchar="q"/>
</options>
<params>
<P1 desc="s (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F475>
<F476 desc="Loop through the records of a sequence to modify the specified field of a table sequence in order. " majortype="101" name="paste" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Loop through the records of sequence Ai to insert them to Fi field of table sequence T before the kth record." optionchar="i"/>
</options>
<params>
<P1 desc="Ai (A table sequence/record sequence/sequence, whose records/members will be values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The field to be modified; when it isn’t supplied, modify the ith field of T)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k (The position the modification starts. The default is 0, in which case records or members will be appended at the end. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F476>
<F477 desc="Perform PCA (Principal Component Analysis) on matrix A and return data for dimensionality reduction; n is the number of principal components" majortype="102" name="pca" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F477>
<F478 desc="Reduce dimensionality for another matrix having same number of columns" majortype="102" name="pca" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(The PCA fiiting object returned by pca(A,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F478>
<F479 desc="Get the first and the last days of the week/month/quarter to which a date belongs" majortype="102" name="pdate" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Get the Sunday of the week to which the specified date belongs" optionchar="w"/>
<O2 defaultselect="false" description="Get the Saturday of the week to which the specified date belongs" optionchar="we"/>
<O3 defaultselect="false" description="Get the beginning day of the month to which the specified date belongs" optionchar="m"/>
<O4 defaultselect="false" description="Get the last day of the month to which the specified date belongs" optionchar="me"/>
<O5 defaultselect="false" description="Get the beginning day of the quarter to which the specified date belongs" optionchar="q"/>
<O6 defaultselect="false" description="Get the last day of the quarter to which the specified date belongs" optionchar="qe"/>
<O7 defaultselect="false" description="Get the first day of the year to which the specified data belongs" optionchar="y"/>
</options>
<params>
<P1 desc="dateExp    (Expression whose result is a date or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F479>
<F480 desc="Calculate Pearson’s correlation coefficient between two vectors" majortype="102" name="pearson" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable the calculation of r2, that is, pearson(norm@0(A),norm@0(B))" optionchar="r"/>
<O2 defaultselect="false" description="Equivalent to @a(…;k) that calculates the adjusted r2 with degrees of freedom being k" optionchar="a"/>
</options>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F480>
<F481 desc="Judge to which enum group an object belongs." majortype="101" name="penum" postfix="E." returntype="101">
<options>
<O1 defaultselect="false" description="Return the serial numbers of all the group satisfying the group conditions, and the default is to  return the serial number of the first group " optionchar="r"/>
<O2 defaultselect="false" description="If no sequence member is found, return the length of E plus 1. This option is mutual exclusive to @r." optionchar="n"/>
</options>
<params>
<P1 desc="y (y is allowed to be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F481>
<F482 desc="Generate a date/time sequence with same interval." majortype="101" name="periods" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="i is in years" optionchar="y"/>
<O2 defaultselect="false" description="i is in quarters" optionchar="q"/>
<O3 defaultselect="false" description="i is in months" optionchar="m"/>
<O4 defaultselect="false" description="i is in ten-days" optionchar="t"/>
<O5 defaultselect="false" description="i is in seconds" optionchar="s"/>
<O6 defaultselect="false" description="exclusive of end point" optionchar="x"/>
<O7 defaultselect="false" description="Not be adjusted. By default, the result will be adjusted to the original start point of the time unit and adjustment must be done in case of @t." optionchar="o"/>
</options>
<params>
<P1 desc="s (a date time variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (a date time variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="i  (an integer indicating the interval; its unit is day and its value is 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F482>
<F483 desc="Return the number of permutations" majortype="102" name="permut" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n   (An integer that is the number of the objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of each way of permutation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F483>
<F484 desc="To find the serial number of a record by its primary key" majortype="101" name="pfind" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the binary search which requires that A must be ordered by the key, otherwise the result will be wrong." optionchar="b"/>
<O2 defaultselect="false" description="Return the opposite number of an insertable position number when the eligible record cannot be found" optionchar="s"/>
</options>
<params>
<P1 desc="k  (Primary key; multiple field values from a composite primary key will be presented in sequence [k1,k2,…] or (k1,k2,…).)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F484>
<F485 desc="Compute the circumference ratio and its multiples" majortype="102" name="pi" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Multiples. If omitting this parameter, then return the circumference ratio)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F485>
<F486 desc="Perform row-to-column transposition for a sequence." majortype="101" name="pivot" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Transpose rows to columns. In this case the default fields in Ni are the fields of A that are not included in g. " optionchar="r"/>
<O2 defaultselect="false" description="@s(g:G,…;F,f(V);Ni:N'i,…),Parameter f can be an aggregate function, which is sum, count, max, min or avg. One and only one Ni can be ignored. In that case the function performs aggregate over all the other Nis." optionchar="s"/>
</options>
<params>
<P1 desc="g (Grouping fields/expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="G(A field in the result set)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (A to-be-transposed field in the specified sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="V (A field in the specified sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="Ni (Values of F field)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="Ni`(The new name of Ni field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
</params>
</F486>
<F487 desc="Compute the plotting string on the canvas G, with the chart element e to plot. Assign the chart element parameter ai with the value xi. If the corresponding coordinate axis is available for this parameter value, then this coordinate axis is Ai." majortype="101" name="plot" postfix="G." returntype="101">
<options/>
<params>
<P1 desc="e (Chart element, for example, MapAxis, NumericAxis, EnumAxis, DateAxis, BackGround, Column, Line, Dot, Polygon, Text, Legend and Sector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ai (Parameters of chart element, for example, the name, logicData, and physicalData parameters in the chart element of MapAxis. For the parameter introduction of each chart element, please refer to parameter chapter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="xi (parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="Ai (Coordinate axis corresponding to the parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F487>
<F488 desc="Fit matrix A and matrix T and return the coefficient; n is the number of principal components" majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F488>
<F489 desc="Fit together matrices using PLS technique and return the coefficient." majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(PLS fitting object returned by pls(A,T,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F489>
<F490 desc="Get the position of the maximum member of a sequence" majortype="101" name="pmax" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
</options>
<params>
<P1 desc="x   (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F490>
<F491 desc="Get the position of the minimum member of a sequence" majortype="101" name="pmin" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
</options>
<params>
<P1 desc="x (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F491>
<F492 desc="Calculate the coefficient between two vectors in polynomial fitting. " majortype="101" name="polyfit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(A non-zero positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F492>
<F493 desc="Get the position of a member in a sequence" majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing are all applicable" optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="Members of A are in order. With the binary search, return the position of x if x is a member of A; otherwise, return a number opposite to the sequence number at which position the x can be inserted orderly." optionchar="s"/>
<O5 defaultselect="false" description="If x is a sequence, then treat it as an single value. In this case, A is a sequence composed of sequences" optionchar="p"/>
<O6 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a." optionchar="n"/>
</options>
<params>
<P1 desc="x (A member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F493>
<F494 desc="Get the positions of sequence members in another sequence." majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return single ascending ISeq p to make A(p)==x" optionchar="i"/>
<O2 defaultselect="false" description="Return the position in which the sequence x firstly appears in A. By doing so, seek the position of sub sequence x in the sequence A. If x is not the sub sequence of A, then return null." optionchar="c"/>
<O3 defaultselect="false" description=" A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable " optionchar="b"/>
</options>
<params>
<P1 desc="x  (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F494>
<F495 desc="Search the position of a substring in a parent string, and return null if not found" majortype="102" name="pos" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform the search leftward starting from begin, while the search will be done rightward by default." optionchar="z"/>
<O2 defaultselect="false" description="Case-insensitive" optionchar="c"/>
<O3 defaultselect="false" description="Search for the subsring at the beginning of the parent string by ignoring parameter begin" optionchar="h"/>
</options>
<params>
<P1 desc="s1 (The parent string where you want to search for the substring.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (Substring of interest.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="begin (The position from which the search starts; the default search is from the beginning.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F495>
<F496 desc="Compute the powers of a numeric value" majortype="102" name="power" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Base)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Power; default is 2)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F496>
<F497 desc="Among the records, query fields referred by the foreign key recursively" majortype="101" name="prior" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r1 (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A Number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F497>
<F498 desc="Call a storage procedure by a database connection" majortype="1" name="proc" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="sql  (The execution statement for the storage procedure; for example, call test(?,?))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="param ( The value of an input argument,  If param:type:mode:variable appears repeatedly, then separate it with comma, like param:type:mode:variable,... )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="type (The data type of an argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="mode (&quot;i&quot; or &quot;o&quot;. &quot;i&quot; indicates an input argument and &quot;o&quot; indicates an output argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="variable (The output argument's name, which will be referenced in the current program cellset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F498>
<F499 desc="Return the product of a set of numbers." majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F499>
<F500 desc="Return the product of a set of numbers." majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F500>
<F501 desc="Retrieve property value from the property file." majortype="2" name="property" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read a property value and parse it as what it is; by default return the value as a string." optionchar="v"/>
</options>
<params>
<P1 desc="p  (Property name; the function returns a table sequence composed of all properties if it is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F501>
<F502 desc="Read property values from node strings." majortype="101" name="property" postfix="xs." returntype="101">
<options>
<O1 defaultselect="false" description="Separate node strings by commas or semicolons; use spaces by default" optionchar="c"/>
<O2 defaultselect="false" description="Use colons to separate node string name and its value; use the equal sign by default" optionchar="j"/>
<O3 defaultselect="false" description="Enclose values by double quotation marks" optionchar="q"/>
<O4 defaultselect="false" description="Read the string and then parse it into value; return a sequence by default" optionchar="v"/>
</options>
<params>
<P1 desc="xs(Node strings, whose format is“name1=value1 name2=value2...”)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Node string name; return a table sequene made up fo all properties when it is absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v(Null or a string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F502>
<F503 desc="Return the sequence number of the interval in which the parameter falls" majortype="101" name="pseg" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use intervals that are left-open and right-closed" optionchar="r"/>
</options>
<params>
<P1 desc="x (An expression, which is a field name or a legal expression made up of field name and in which the sign ~ can be used to reference the current record; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F503>
<F504 desc="Get the positions of the selected members from a sequence" majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="The member in A is ordered for formula x. With the binary search, if none members in A can make the formula x generate a result of 0, then return a number opposite to the position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
</options>
<params>
<P1 desc="x  (A boolean expression, whose value can be null. when using @b option, x should be an expression whose return value is an integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F504>
<F505 desc="Get the positions of the selected members from a sequence, the simplified syntax for multiple conditions using &quot;&amp;&amp;&quot; to do the union query, it is equal to A.pselect(x1==y1 &amp;&amp; x2==y2 &amp;&amp;...... xi==yi {,k})." majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="All members of A are in descending/ascending order for formula xk. With binary search, if no members meeting the conditions are found, then return a number opposite to the sequence number of position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
</options>
<params>
<P1 desc="xi    (xi is an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi    (yi is a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F505>
<F506 desc="Get the original positions of the sorted members of a sequence." majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="x (the sorting expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F506>
<F507 desc="Get the original positions of the sorted members of a sequence." majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="xi (If there are multiple sorting expressions, they can be written as xi:di,.., a compound expression consisting of multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F507>
<F508 desc="Get the sequence numbers of the top n smallest members in a sequence" majortype="101" name="ptop" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1" optionchar="1"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Sort expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F508>
<F509 desc="Push data in a channel into another channel." majortype="101" name="push" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F509>
<F510 desc="Push data in a cursor into a channel." majortype="101" name="push" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F510>
<F511 desc="Execute a SQL statement on a data source and return a table sequence composed of the query results.  " majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function." optionchar="x"/>
</options>
<params>
<P1 desc="sql (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F511>
<F512 desc="Perform sql based on A and return a table sequence composed of query results. Here, args can be an expression evaluated based on each member of A. This type of syntax can work with @idx options." majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function. " optionchar="x"/>
</options>
<params>
<P1 desc="A  (A sequence. sql is executed on each member of A. Generally args is computed against each member of A and the value is passed to sql for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql  (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args  (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F512>
<F513 desc="Connect to esProc-ODBC data source db to call the specified dfx file and return a result" majortype="101" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which is a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function. " optionchar="x"/>
</options>
<params>
<P1 desc="call dfx() (Dfx is a cellset file; can be specified using a relative path, which is relative to the search path, or an absolute path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments. )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F513>
<F514 desc="Find a certain field of a specified row in a table sequence/memory table" majortype="101" name="r" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T(A table sequence/memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(A field of T; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F514>
<F515 desc="Close R2DBC connection." majortype="102" name="r2dbc_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="r2dbc_open(R2DBC connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F515>
<F516 desc="Execute a SQL statement through R2DBC." majortype="102" name="r2dbc_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F516>
<F517 desc="Connect to R2DBC and return a cursor." majortype="102" name="r2dbc_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The URL for accessing a database, whose format is r2dbc:dbtype://&lt;host&gt;:port/&lt;database&gt;)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F517>
<F518 desc="Query a database through R2DBC." majortype="102" name="r2dbc_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Databae connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL statement to be queried, such as select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F518>
<F519 desc="Get the integers from 0 to n-1." majortype="102" name="rand" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the seed value for generating random number." optionchar="s"/>
</options>
<params>
<P1 desc="n (Integer,by default, the result is a random float number between 0 and 1.0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F519>
<F520 desc="Get a random character string" majortype="102" name="rands" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Character string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F520>
<F521 desc="Get the beginning members of the specified segment and its next segment" majortype="101" name="range" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Starting data)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Ending data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k (The kth segment whose beginning member is to be returned)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n (The number of segments data is divided)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F521>
<F522 desc="Compute the ranking of a specified value in a sequence" majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting y’s ranking. " optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F522>
<F523 desc="Get the ranking of a certain member in the computed sequence." majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting y’s ranking." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A or it is used to compare with values of sequence A.(x))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F523>
<F524 desc="An interative loop for numbering records according to the values of certain fields." majortype="102" name="rank" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F524>
<F525 desc="An interative loop for numbering records according to the values of certain fields." majortype="102" name="ranki" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name; under same Gi field value, records with same F field value have same sequence number; add 1 to the sequence number if F field value changes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name; in a loop function, number records under same Gi field value by the changes of F field value; renumber a record when Gi field value changes. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F525>
<F526 desc="Get the rankings of members of sequence A.(x)" majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F526>
<F527 desc="Compute the ranking of each member in a sequence." majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params/>
</F527>
<F528 desc="Read contents from a file object" majortype="2" name="read" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return the contents of the file object f as a string sequence; each row is corresponding to a member." optionchar="n"/>
<O2 defaultselect="false" description="Interpret the returned string as the corresponding data type. The combined use of this option and @n is acceptable" optionchar="v"/>
<O3 defaultselect="false" description="Read the file once and return the total number of bytes in it; used for test" optionchar="0"/>
</options>
<params>
<P1 desc="b(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F528>
<F529 desc="Make the members of a sequence the new field values of records of a table sequence." majortype="101" name="record" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="insert new records before the specified position k" optionchar="i"/>
<O2 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences" optionchar="n"/>
</options>
<params>
<P1 desc="A (a sequence whose members will be used as field values of T)" filtertype="1" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (an integer, which indicates the record position from which the records will be modified        If k==0 or k is omitted, then append new records to T )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F529>
<F530 desc="Modify field values of a record with members of a sequence." majortype="101" name="record" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="A (A sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F530>
<F531 desc="Connect to a Redis database under the single machine model" majortype="102" name="redis" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort   (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F531>
<F532 desc="Close a Redis database connection" majortype="102" name="redis_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F532>
<F533 desc="Connect to Redis Cluster" majortype="102" name="redis_cluster" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="maxRedirections  (The maximum number of allowed redirections; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F533>
<F534 desc="Get the values of all the given keys" majortype="102" name="redis_get" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F534>
<F535 desc="Get a substring of the string stored at a key" majortype="102" name="redis_getrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (The beginning of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="end  (The end of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F535>
<F536 desc="Get all the fields in a hash" majortype="102" name="redis_hkeys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F536>
<F537 desc="Get the number of fields in a hash" majortype="102" name="redis_hlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F537>
<F538 desc="Get the values of all the given hash fields" majortype="102" name="redis_hmget" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="field  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F538>
<F539 desc="Get the values of all hash fields" majortype="102" name="redis_hvals" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F539>
<F540 desc="Find all keys matching the specified pattern" majortype="102" name="redis_keys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pattern  (A matching string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F540>
<F541 desc="Get a member from a list by its index" majortype="102" name="redis_lindex" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="index  (Index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F541>
<F542 desc="Get the length of a list" majortype="102" name="redis_llen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F542>
<F543 desc="Get a range of members in a list with indexes within the given offset values start and stop." majortype="102" name="redis_lrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F543>
<F544 desc="Connect to Redis database in buffer pool mode" majortype="102" name="redis_pool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="database  (Database indexes, which within the range of 0~15; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="clientName  (Client name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F544>
<F545 desc="Get the the number of members in a set" majortype="102" name="redis_scard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F545>
<F546 desc="Get members of the difference set of all the given sets" majortype="102" name="redis_sdiff" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F546>
<F547 desc="Change the selected database for the current connection; the database index is a number that starts from 0" majortype="102" name="redis_select" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="index  (Index number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F547>
<F548 desc="Connect to distributed Redis cluster" majortype="102" name="redis_sentinel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="master  (Master node name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F548>
<F549 desc="Connect to a Redis database in shared pool mode" majortype="102" name="redis_shared" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F549>
<F550 desc="Connect to a Redis database in a mode of both buffer pool and shared pool" majortype="102" name="redis_sharedpool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F550>
<F551 desc="Get members of the intersection of all the given sets" majortype="102" name="redis_sinter" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F551>
<F552 desc="Determine if a given value is a member of a set" majortype="102" name="redis_sismember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Set element)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F552>
<F553 desc="Get all members of a set" majortype="102" name="redis_smembers" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F553>
<F554 desc="Get one or multiple random members from a set" majortype="102" name="redis_srandmember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="count  (The number of returned members; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F554>
<F555 desc="Get the length of the string value stored in the key" majortype="102" name="redis_strlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F555>
<F556 desc="Get the members of the union of all the given sets" majortype="102" name="redis_sunion" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F556>
<F557 desc="Get the data type of the value stored in the key" majortype="102" name="redis_type" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F557>
<F558 desc="Get the number of members in a sorted set" majortype="102" name="redis_zcard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F558>
<F559 desc="Count the number of members in a sorted set with scores between a given interval" majortype="102" name="redis_zcount" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The starting score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The ending score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F559>
<F560 desc="Return a range of members in a sorted set, by index" majortype="102" name="redis_zrange" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange members in a descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F560>
<F561 desc="Return a range of members in sorted set, by score" majortype="102" name="redis_zrangebyscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc=" con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The smallest score; can be –inf, meaning infinitely small)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The greatest score; can be +inf, meaning inifinitely large)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="offset  (Offset interval; can be omitted along with the parameter n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="n  (Offset value; can be omitted along with the parameter offset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F561>
<F562 desc="Determine the index of a member in a sorted set" majortype="102" name="redis_zrank" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange sorted set members in descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F562>
<F563 desc="Get the score associated with the given member in a sorted set" majortype="102" name="redis_zscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F563>
<F564 desc="If no extracting item is specified in rs which represents regular expressions, match field Fi of the string data type with rs. Then return the new RSeq after RSeq A is filtered. Use the current record to match with rs if omitting Fi" majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F564>
<F565 desc="Split the string members of sequence A according to specified regular expressions in rs, the series of regular expressions, and return the results as a TSeq whose fields are Fi " majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F565>
<F566 desc="Match the character string with regular expression" majortype="101" name="regex" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F566>
<F567 desc="Match the member of character string in the cursor with the regular expression" majortype="101" name="regex" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Result field name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F567>
<F568 desc="Register a .dfx/.splx file as a function to be called." majortype="102" name="register" postfix="" returntype="101">
<options/>
<params>
<P1 desc="f(Function name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="spl(.dfx/splx file path, which can be an absolute path or a relative path; a relative path is relative to the main directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F568>
<F569 desc="Rename the fields in a table sequence/(multi-zone) entity table" majortype="101" name="rename" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F569>
<F570 desc="Rename a field of a cursor" majortype="101" name="rename" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="F(Field name/index name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F1 (New name of the field; If omitted, delete the original names and name the fields _1,2...)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F570>
<F571 desc="Change the substring of a source string" majortype="102" name="replace" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Quoted characters need not to be replaced" optionchar="q"/>
<O2 defaultselect="false" description="Enble to replace the first-found specified substring only" optionchar="1"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
</options>
<params>
<P1 desc="src (Source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (The source substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The target substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F571>
<F572 desc="Read information from the configuration file. " majortype="101" name="report_config" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(A file path, which is either a relative path or an absolute path; for a relative path, its base directory is the esProc installation directory.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F572>
<F573 desc="Export a report as a HTML file or an MHT file. " majortype="101" name="report_exportHtml" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export the report file into an MHT format; the default format of the exported file is HTMl." optionchar="x"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F573>
<F574 desc="Export a report as a PDF file. " majortype="101" name="report_exportPdf" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export a report as a paginated PDF" optionchar="p"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F574>
<F575 desc="Export a report as an xls file or an xlsx file." majortype="101" name="report_exportXls" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export the report as an xlsx file" optionchar="x"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath(The exported file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F575>
<F576 desc="Read a report file. " majortype="101" name="report_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(The report file path, which is either a relative path or an absolute path; for a relative path, its base directory is the content of &lt;home&gt; in the configuration file.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F576>
<F577 desc="Compute a report file." majortype="101" name="report_run" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramValue(Report parameter value; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName(Report parameter name; if it is omitted, write the report parameter values in its original order. It is illegal to write only some report parameter names while omitting others; the colon (;) following the parameter should always be rertained.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F577>
<F578 desc="Reset a cursor by moving it back to the beginning" majortype="102" name="reset" postfix="cs." returntype="102">
<options/>
<params/>
</F578>
<F579 desc="Reorganize a composite table and write it to another composite table file." majortype="2" name="reset" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the file as an uncompressed one; perform the write as usual if the parameter is omitted" optionchar="u"/>
<O2 defaultselect="false" description="Write the file as a compressed one; won’t perform compression if the option is absent" optionchar="z"/>
<O3 defaultselect="false" description="Write the file by row; perform the write as usual if the parameter is omitted" optionchar="r"/>
<O4 defaultselect="false" description="Write the file by column" optionchar="c"/>
<O5 defaultselect="false" description="A quick reset" optionchar="q"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F579>
<F580 desc="Clear the members of a table sequence" majortype="101" name="reset" postfix="T." returntype="101">
<options/>
<params/>
</F580>
<F581 desc="Get result of an operation performed in a channel." majortype="101" name="result" postfix="ch." returntype="101">
<options/>
<params/>
</F581>
<F582 desc="Convert the red, green, blue, and transparency value to the corresponding color value" majortype="102" name="rgb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="redIntExp      (The integer expression to indicate the red, of which the value is between 0-255)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="greenIntExp (The integer expression to indicate the green, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="blueIntExp    (The integer expression to indicate the blue, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="alphaIntExp  (The integer expression to indicate the transparency, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F582>
<F583 desc="Build models and perform predictions using the ridge regression method." majortype="102" name="ridge" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F583>
<F584 desc="Get the substring from the right of a string" majortype="102" name="right" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s     (Source string from which to get the substring )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n     (Get the length of substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F584>
<F585 desc="Roll back a database transaction." majortype="1" name="rollback" postfix="db." returntype="102">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F585>
<F586 desc="Restore a composite table file to the previous state when update error happens" majortype="101" name="rollback" postfix="f." returntype="101">
<options/>
<params/>
</F586>
<F587 desc="Truncate the data at the specified position, and round off the remaining part" majortype="102" name="round" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer to specify the position at which to intercept ,＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F587>
<F588 desc="Find the record where the key value(s) is/are the specified one(s)." majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A record sequence/a table sequence/a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F588>
<F589 desc="Find records from a memory table according to the specified primary key value(s)." majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F589>
<F590 desc="Compute an expression against a record and return the modified record.  The function computes the expression x against record r and return the modified record. Usually it is used to change the field values of r, for example, when x is col1=col2+1, it will change the field value of col1." majortype="101" name="run" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="xi (An expression, which is generally a field name or a legal expression composed of field names, and in which &quot;~&quot; references the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F590>
<F591 desc="Compute expressions against each member of a sequence. Set the field value of Fi to xi." majortype="101" name="run" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="xi    (The new value of Fi field )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi    (A field of A)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F591>
<F592 desc="Compute one or more expressions against each member in a sequence/record sequence and return a sequence composed of values of the expression." majortype="101" name="run" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set." optionchar="m"/>
</options>
<params>
<P1 desc="x (An expression, which is generally a field name or a legal expression that is composed of field names, and in which &quot;~&quot; is used to reference the current record. ) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F592>
<F593 desc="Compute an expression against each of the records in a channel and return the channel with new field values." majortype="101" name="run" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (New values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F593>
<F594 desc="Compute one or more expressions against each of the records in a cursor and return the modified cursor. " majortype="101" name="run" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (A field of cs)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F594>
<F595 desc="Generate a new sequence by reversing the members in a sequence" majortype="101" name="rvs" postfix="A." returntype="101">
<options/>
<params/>
</F595>
<F596 desc="Exit an SAP server connection" majortype="102" name="sap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (SAP connection file handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F596>
<F597 desc="Return the list of table-valued result set as a cursor" majortype="102" name="sap_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F597>
<F598 desc="Get a function object according to the import parameter(s)" majortype="102" name="sap_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName (The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="paramValue (Function parameter value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F598>
<F599 desc="Get data records according to the import parameter(s)" majortype="102" name="sap_getparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F599>
<F600 desc="Connect to an SAP server" majortype="102" name="sap_open" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F600>
<F601 desc="Connect to an SAP server" majortype="102" name="sap_open" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="charset (Character set of the connection configuration file)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F601>
<F602 desc="Connect to an SAP server" majortype="102" name="sap_open" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="FileObject (Connection configuration file object handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F602>
<F603 desc="Connect to an SAP server" majortype="102" name="sap_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="user (SAP user name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="passwd (SAP password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hostname" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="sysnc (SAP server’s IP)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="client (System number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="lang (Language)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F603>
<F604 desc="Return a list according to the import table-valued parameter" majortype="102" name="sap_table " postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F604>
<F605 desc="Set the savepoint to which you can later rollback" majortype="102" name="savepoint" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F605>
<F606 desc="Get the second from a time" majortype="102" name="second" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp    (Expression whose result is a time or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F606>
<F607 desc="Return the member in a sequence corresponding to a certain interval number" majortype="101" name="segp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use left-open and right-closed intervals" optionchar="r"/>
</options>
<params>
<P1 desc="x(A field expression or a legal expression made up of field names, in which “~” can be used to reference the current record and which can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F607>
<F608 desc="Pick out members from a sequence which satisfied a condition." majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions." optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable. Note: If A is not a sorted sequence, then option @b should not be used, or it may  bring about the incorrect result. When option @b is used in A.select(x1:y1, x2:y2, ......xi:yi), that is to find out the members whose &quot;Return value&quot; are 0 in cmp(x,y), cmp() is not needed in this  syntax, A.select@b(x1:y1, x2:y2, ......xi:yi) is enough. " optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O6 defaultselect="false" description="Enable getting the first ineligible member from left to right beginning from the first member" optionchar="c"/>
<O7 defaultselect="false" description="Enable searching for the first eligible members from left to right and getting all members after it (inclusive)" optionchar="r"/>
</options>
<params>
<P1 desc="x (an Boolean expression, which may be null. when using option @b, x should be an expression  whose return value is a number )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F608>
<F609 desc="Pick out members from a sequence which satisfied a condition. The simplified syntax used for the combining query with multiple conditions using &quot;&amp;&amp;&quot;, which is equal to A.select(x1== y1 &amp;&amp; x2== y2 &amp;&amp;...... xi==yi). While using option @b in case of multiple conditions, cmp() is not needed in this syntax and A.select@b(x1:y1, x2:y2, ......xi:yi) is enough" majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions. " optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable. Note: If A is not a sorted sequence, then option @b should not be used, or it may  bring about the incorrect result. When option @b is used in A.select(x1:y1, x2:y2, ......xi:yi), that  is to find out the members whose &quot;Return value&quot; are 0 in cmp(x,y), cmp() is not needed in this  syntax, A.select@b(x1:y1, x2:y2, ......xi:yi) is enough. " optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
</options>
<params>
<P1 desc="xi   (an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi   (a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F609>
<F610 desc="Return members of a table sequence which satisfy a condition" majortype="101" name="select" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Reuse T’s index, which may disrupt the order of the result set" optionchar="i"/>
</options>
<params>
<P1 desc="x(Filtering expression; can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F610>
<F611 desc="Return a channel with records that meet the given condition." majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F611>
<F612 desc="Send records in a channel that can’t meet the given condition into another channel." majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F612>
<F613 desc="Return a cursor with records meeting the given condition" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F613>
<F614 desc="Send records in a cursor that can’t meet the given condition into a channel." majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1 (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F614>
<F615 desc="Write the records that unsatisfy the specified expression into a BIN file" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (BIN file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F615>
<F616 desc="An interative loop for numbering records in which a certain field contains same values." majortype="102" name="seq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers Return value: " optionchar="n"/>
</options>
<params>
<P1 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F616>
<F617 desc="Close Salesforce cloud server connected through the way of rest api." majortype="102" name="sf_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F617>
<F618 desc="Connect to Salesforce cloud server through the way of rest api." majortype="102" name="sf_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="jsonFile(The JSON file name; by default call user.json in the directory containing SalesforcCli external library)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F618>
<F619 desc="Query data and return result." majortype="102" name="sf_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The service domain path preceded by /services)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(The parameter corresponding to url)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F619>
<F620 desc="Close the cloud server Salesforce server connected through soap api." majortype="102" name="sf_wsdlclose" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F620>
<F621 desc="Connect to Salesforce server cloud service through soap api." majortype="102" name="sf_wsdlopen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="username(User name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password(Password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F621>
<F622 desc="Query data and return query result." majortype="102" name="sf_wsdlquery" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sql(A SQL statement; does not support select * from table. Users can refer to the value returned by sf_wsdlview() to write corresponding fields)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F622>
<F623 desc="Query data in an Sobject object and return a table sequence made up of field names and field types." majortype="102" name="sf_wsdlview" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sobject(The Soobject data object to be queried)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F623>
<F624 desc="Perform SG smoothing on each row of a vector or a matrix." majortype="102" name="sg" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Degree of a polynomial that satisfies n&lt;m-1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="m(A set of data points, which is an odd number greater than 1 and will automatically plus 1 if it isn’t an odd number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d(The nth order derivative, which satisfies d&lt;n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F624>
<F625 desc="Perform a shift operation." majortype="102" name="shift" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="When shifting right, shift a sign into the leftmost position and shif a zero to this position by default" optionchar="s"/>
</options>
<params>
<P1 desc="x (The expression based on which you perform the shift operation)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F625>
<F626 desc="Get a shuffled sequence." majortype="101" name="shift" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="i (The starting position, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (The offset value, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F626>
<F627 desc="Judge whether the parameter is a positive number, a negative number or 0." majortype="102" name="sign" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Data for which you want to judge whether it is positive or negative)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F627>
<F628 desc="Compute the sine value." majortype="102" name="sin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F628>
<F629 desc="Return the hyperbolic sine" majortype="102" name="sinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F629>
<F630 desc="Get the length of a file." majortype="2" name="size" postfix="f." returntype="101">
<options/>
<params/>
</F630>
<F631 desc="To skip records while fetching records from a database cursor" majortype="101" name="skip" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, by which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F631>
<F632 desc="Make esProc program sleep." majortype="102" name="sleep" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (Millisecond)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F632>
<F633 desc="Generate a new sequence by sorting the members of a sequence" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="x (an expression, according to which the members of sequence A will be sorted ascendingly)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F633>
<F634 desc="Generate a new sequence by sorting the members of a sequence" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="xi (An expression, which is a member of sequence A and which will be sorted in ascending order. If there are multiple expressions, they can be written as a compound expression in the form of xi:di,.., according to which the sorting will be performed)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F634>
<F635 desc="Sort records in a channel." majortype="101" name="sortx" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (An expression, according to which the records in a given channel is sorted in acending order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F635>
<F636 desc="Sort data of a cursor." majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Put records with null values at the end; @0 and @n can’t work together." optionchar="0"/>
<O2 defaultselect="false" description="It can only be used to make the calculation faster when the value of expression x is a positive integer over which group of records can be directly numbered. @0 and @n can’t work together." optionchar="n"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
</options>
<params>
<P1 desc="x (An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F636>
<F637 desc="Sort a cluster cursor." majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t merge result sets returned by the nodes but return a cluster cursor segmented in the same way " optionchar="c"/>
</options>
<params>
<P1 desc="x(An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F637>
<F638 desc="Close a Spark database connection." majortype="102" name="spark_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Spark database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F638>
<F639 desc="Query a Spark database, and return the result as a cursor." majortype="102" name="spark_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F639>
<F640 desc="Create a Spark database connection." majortype="102" name="spark_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information; the format is hdfs://ip:port, which represents the HDFS file’s IP and port number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information; the format is thrift://ip:port, which represents the Thrift file’s IP and port number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F640>
<F641 desc="Query a Spark database, and return the result as a sequence." majortype="102" name="spark_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F641>
<F642 desc="Read a file stored in Spark database." majortype="102" name="spark_read" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Read content of a file and return result as a cursor" optionchar="c"/>
<O2 defaultselect="false" description="Read the first row of a text file as field names, which is equivalent to &quot;header&quot;:&quot;true&quot;; by default, use the automatically generated field names c0, _c1…" optionchar="t"/>
<O3 defaultselect="false" description="Close Spark database connection" optionchar="x"/>
</options>
<params>
<P1 desc="con(Local or HDFS connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sfile(File name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k:v(Parameters that can be omitted. When sfile is a text file separated by “；”, set the pair as ”sep”:”;”; and when the text file is separated by “#”, set the pair as ”sep”:”#”)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F642>
<F643 desc="Calculate Spearman’s correlation coefficient between two vectors" majortype="102" name="spearman" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F643>
<F644 desc="Split a string by delimiter so as to form a new sequence" majortype="101" name="split" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="It splits string into 2 parts by the first d found" optionchar="1"/>
<O2 defaultselect="false" description="Parse members into corresponding data types after the splitting. That is to say, numbers shall be handled as numeric values, members enclosed by [] shall be recognized as sequences, dates like 2001-01-01 shall be treated as date type data, and so on. The parsing of the sign [] also involves the same handling of a sub-sequence. In addition, parentheses matching needs to be handled." optionchar="p"/>
<O3 defaultselect="false" description="It parses members into corresponding data types without handling quotation marks matching and parentheses matching" optionchar="b"/>
<O4 defaultselect="false" description="Perform trim operation to remove blank characters from the front and end of each string member, and split the original string according to continuous blank characters when d==&quot;&quot;" optionchar="t"/>
<O5 defaultselect="false" description="Treat parameter d as a regular expression" optionchar="r"/>
<O6 defaultselect="false" description="Spit a string using the carriage return \n, and split each substring according to the other options if there are any, and return a sequence of sequences" optionchar="n"/>
</options>
<params>
<P1 desc="d  (The delimiter; if it is omitted, split the string into a sequence of single characters.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F644>
<F645 desc="Split a SQL query into a sequence." majortype="101" name="sqlparse" postfix="sql." returntype="101">
<options>
<O1 defaultselect="false" description="SELECT statement" optionchar="s"/>
<O2 defaultselect="false" description="FROM clause, including the JOIN" optionchar="f"/>
<O3 defaultselect="false" description="WHERE clause" optionchar="w"/>
<O4 defaultselect="false" description="GROUP BY statement" optionchar="g"/>
<O5 defaultselect="false" description="HAVING clause" optionchar="h"/>
<O6 defaultselect="false" description="ORDER BY statement" optionchar="o"/>
<O7 defaultselect="false" description="Split each statement/clause into smaller parts; separate WHERE and HAVING clauses according to AND" optionchar="a"/>
</options>
<params>
<P1 desc="part (A SQL string for replacing a statement/clause in the original SQL query; need to work with a certain option)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F645>
<F646 desc="Translates standard SQL functions into functions a specified database defines." majortype="101" name="sqltranslate" postfix="sql." returntype="101">
<options/>
<params>
<P1 desc="dbtype (Database type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F646>
<F647 desc="Find the square root of a number" majortype="102" name="sqrt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Data for which you want to find the square root)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F647>
<F648 desc="Close connection to the Cassandra database" majortype="102" name="stax_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Cassandra database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F648>
<F649 desc="Query the Cassandra database and return result as a cursor" majortype="102" name="stax_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient(The database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql(A CQL query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args(A parameter value; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F649>
<F650 desc="Create connection to the Cassandra database" majortype="102" name="stax_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nodes (The to-be-connected database’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (Port number; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user:pwd (User name and password; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyspace (The keyspace name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="compressor (A compression algorithm, which is LZ4, Snappy and none; default is none)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="version(Protocol version information; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="queryOptions(A query option, which includes ANY, ONE, TOW, THREE, ALL and QUORUM; there are details in Cssandra documentation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F650>
<F651 desc="Query a Cassandra database and return the query result as a table sequence" majortype="102" name="stax_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql (The query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (Parameter values; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F651>
<F652 desc="Create a sequence by getting members from a sequence according to the specified starting position and a step." majortype="101" name="step" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="m  (a positive integer used to specify the span)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ki  (the starting serial number, 1≤ki.The default is 1.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F652>
<F653 desc="Convert the object of other type to the string type and format it" majortype="102" name="string" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enclosed the string expression in double quotes and ignore parameter format" optionchar="q"/>
<O2 defaultselect="false" description="Escape the undisplayable character. Represent the tab, carriage return, line break in the string expression with the escape characters. Add an escape character before the single quotes, double quotes or an escape character if there is any in the string. Ignore parameter format" optionchar="e"/>
<O3 defaultselect="false" description="With the use of @e option, if there is large character set in the string expression, convert it to Unicode characters" optionchar="u"/>
</options>
<params>
<P1 desc="expression (The constant object or expression to be converted to string.)" filtertype="0" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format  (A format string used to format the result of expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F653>
<F654 desc="Find a substring and return the string after the substring" majortype="101" name="substr" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the string before s2; return null if there is nothing before s2" optionchar="l"/>
<O2 defaultselect="false" description="Skip the quoted string" optionchar="q"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
</options>
<params>
<P1 desc="s1 (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (A string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F654>
<F655 desc="Compute x with each member of the sequence and compute the summary value of the members of the new sequence, Equivalent to A.(x).sum()" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names. The data type of the computed result of the expression is numerical value.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F655>
<F656 desc="Compute the sum of members of a sequence.  Equivalent to sum(x1,…,xn)" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params/>
</F656>
<F657 desc="Generate a new sequence by swapping the member positions of two specified intervals of a sequence" majortype="101" name="swap" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence interval composed of positive integers, for example [1,2,3 ], to (1,3))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="q  (an integer sequence interval composed of positive integers and does not have intersection with p, for example [ 4,5,6], to(4,6))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F657>
<F658 desc="Switch the reference field between the field value and the referenced record" majortype="101" name="switch" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove this record if no value corresponding to F is found in the procedure." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F; with the option do not populate F with nulls. " optionchar="d"/>
<O3 defaultselect="false" description="If the specified F field value of a specified record in sequence A doesn’t exist in sequence B, generate a record of the same structure as one in B with F field as the primary key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The key of A. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai. They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of A, which stores corresponding primary key values. The function is used to switch them to the referenced records. The ma. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both parameter Ai and the primary key x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field. If x is #, locate the records directly through the sequence numbers.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F658>
<F659 desc="Switch the values of a reference field in a channel between the corresponding primary key values and the referenced records, or, sometimes switch between them in a reverse direction. " majortype="101" name="switch" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F." optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primay key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The reference field of A. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai . They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of A, which stores corresponding primary key values. The function is used to switch them to the referenced records in Ai.The matching condition is that Fi is equal to the primary key value of Ai. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both Ai and x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F659>
<F660 desc="Replace values of a certain field in a cursor with the referencing field values of the corresponding record in another table" majortype="101" name="switch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Connect on condition that the values are equal. By default, start connecting from the left. If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F" optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primay key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi (A field of a cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F660>
<F661 desc="Replace values of a specified field in a cluster cursor with the referencing field values of the corresponding record in another table" majortype="102" name="switch" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="With a distributed cluster memory table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="Fi (A field in the cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai (A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (The primary key or logical of Ai; the parameter can be omitted if Ai has the primary key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F661>
<F662 desc="Replace values of specified fields in an in-memory table with the corresponding referencing field values" majortype="101" name="switch" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record from T if its Fi value does not have a match in Ai" optionchar="i"/>
<O2 defaultselect="false" description="Opposite to @i option, it enables to retain only the non-matching records in T; and in this case, Fi won’t be recorded as null" optionchar="d"/>
<O3 defaultselect="false" description="Generate a record of same structure as Ai if the Fi value of a record of T does not have a match in Ai; the primary key of the new record will be Fi" optionchar="1"/>
</options>
<params>
<P1 desc="Fi(A field of T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(An in-memory table or a table squence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(The (logical) primary key of Ai; if a specific primary is set for Ai, the parameter can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F662>
<F663 desc="Synchronize a local path onto a sequence of nodes." majortype="102" name="syncfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p(A local path)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F663>
<F664 desc="It is used to call the system command, and return the result once completed. For example, to open the bat and exe file." majortype="102" name="system" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Proceed with the execution without pause" optionchar="p"/>
</options>
<params>
<P1 desc="cmd/sh   (&lt;strong&gt;cmd&lt;/strong&gt; cmd parameter style is set to “cmd /c +command”(Windows). &lt;br&gt; or &lt;strong&gt;sh&lt;/strong&gt; sh parameter style is set to “sh -c +command” (Linux).)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F664>
<F665 desc="Compute the tangent value" majortype="102" name="tan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the tangent value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F665>
<F666 desc="Return the hyperbolic tangent" majortype="102" name="tanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number  (The real number for which you want to find the hyperbolic tangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F666>
<F667 desc="Get the time part from the datetime value" majortype="102" name="time" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
</options>
<params>
<P1 desc="datetimeExp (datetime data )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F667>
<F668 desc="Convert the string stringExp to time data type according to the format specified by format and return null if the conversion fails. If there is no parameter format, format of stringExp must be in consistent with the time format in the configuration information. Parameter loc is the language used in stringExp; default is the system language." majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp    (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A string specifying data format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F668>
<F669 desc="Convert h,m,s of integer type to time data type" majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="H  (integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="s  (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F669>
<F670 desc="T inverse cumulative distribution function." majortype="102" name="tinv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nu(Degrees of freedom corresponding to probabilities)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F670>
<F671 desc="From sequence A, generate a sequence composed of the first a members; when a&lt;0, get members from the (A.len()+1+a)th one to the (A.len())th one." majortype="101" name="to" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="@z(i,n). Split a sequence into a number of segments (the number is n), and get and return the ith segment" optionchar="z"/>
</options>
<params>
<P1 desc="a (the integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F671>
<F672 desc="From the sequence A, generate a sequence composed of the members from the ath to the bth. If omitting a, then start from the first member by default; if omitting b, get all members of A, that is A.len(), by default, and in this case the comma must not be omitted; if a&gt;b, find the members backwards; members of the newly-generated sequence are ordered in an opposite direction relative to their original order." majortype="101" name="to" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="@z(i,n)  Split a sequence into a number of segments (the number is n), and get and return the ith segment. If the number of members in the sequence can’t be evenly divided, the additional members will be returned along with the last segment" optionchar="z"/>
</options>
<params>
<P1 desc="a (The integer specifying the starting position.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The integer specifying the ending position.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F672>
<F673 desc="Generate a sequence composed of continuous integers between a and b." majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="start (the starting integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="end (the ending integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F673>
<F674 desc="Generate a sequence composed of continuous integers from 1 to n." majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="n (n&gt;0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F674>
<F675 desc="Calculates expression x over each member of the sequence and return a sequence consisting of the first n smallest values of x" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F675>
<F676 desc="Calculates expression x over each member of the sequence and return a sequence consisting of the first n smallest members" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F676>
<F677 desc="Loop members of sequence A to compute expression x, then loop the results to compute expression y, and finally return a sequene of x’s results that correspond to the top n smallest values of y." majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Calculate the concatenation of all sequence-type members in sequence A and get the first n smallest members from the new sequence" optionchar="2"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F677>
<F678 desc="Perform aggregatgion over records in a cursor" majortype="101" name="total" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F678>
<F679 desc="Perform aggregatgion over records in a channel" majortype="101" name="total" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F679>
<F680 desc="Transpose a matrix." majortype="101" name="transpose" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F680>
<F681 desc="Remove the space on both ends of a string" majortype="102" name="trim" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove the spaces on the left of the string s, and the option is letter l" optionchar="l"/>
<O2 defaultselect="false" description="Remove the spaces on the right of string s" optionchar="r"/>
<O3 defaultselect="false" description="Remove all extra whitespaces. If there is one or continuous whitespaces within the string, retain only one whitespace; remove the whitespaces between a character and a word, but retain the whitespaces within the quotation marks." optionchar="a"/>
</options>
<params>
<P1 desc="s      (Source string from which you want to remove the space)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F681>
<F682 desc="Try to continue with the execution of a code block by ignoring the error. " majortype="101" name="try" postfix="" returntype="101">
<options/>
<params/>
</F682>
<F683 desc="Compute the union of members in a sequence whose members are sequences" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params/>
</F683>
<F684 desc="Compute x with each member of the sequence whose members are sequences, and then perform union operation on members of the new sequence" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F684>
<F685 desc="Update a database table based on a sequence/record sequence" majortype="1" name="update" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="Compare primary keys between the database table and A1 to generate an UPDATE statement; skip the comparison and directly upadate the database table with A if A1 is absent." optionchar="u"/>
<O2 defaultselect="false" description="Compare primary keys between the database table with A1 generate INSERT statement; skip the comparison and directly insert records into the database table with A if A1 is absent." optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update(A:A1,tbl,Fi:xi,...;P,...)." optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="1"/>
<O6 defaultselect="false" description="Only perform delete operation and A1 must be in place. " optionchar="d"/>
</options>
<params>
<P1 desc="A  (A sequence / record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A1 (The original sequence/record sequence, whose data is considered consistent with the database table. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="tbl (The name of a table in the database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi  (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="xi (An expression which will be computed against A and then will be used as the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="P (The primary key of tbl.If omitted, these keys will be retrieved from tbl. If retrival is failed, then use A)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F685>
<F686 desc="Update a database table based on a cursor" majortype="1" name="update" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Generate UPDATE statement" optionchar="u"/>
<O2 defaultselect="false" description="Generate INSERT statement" optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update()" optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not  be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="l"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl (The name of a database table )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="xi (An expression which will be computed based on A and its value will be the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="P (The key of tbl. If omitted, it will be retrieved from tbl; if the retrieval fails, then use A’s)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F686>
<F687 desc="Update records in an entity table." majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Update the records that can be inserted and ignore those whose values exist in the memory table" optionchar="i"/>
<O2 defaultselect="false" description="Update the records that can be modified and ignore those whose values don’t exist in the memory table" optionchar="u"/>
<O3 defaultselect="false" description="Return only the records that are updated and inserted" optionchar="n"/>
</options>
<params>
<P1 desc="P (A table sequence/record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F687>
<F688 desc="Convert all characters to upper case" majortype="102" name="upper" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The quoted strings won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s     (Source string to be converted to upper case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F688>
<F689 desc="Convert a URL string into an encoded string" majortype="102" name="urlencode" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decode, which is the inverse operation of the urlencode function" optionchar="r"/>
</options>
<params>
<P1 desc="s (A URL string to be encoded)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F689>
<F690 desc="Get the primary key value of the record pointed by a referencing field." majortype="101" name="v" postfix="v." returntype="101">
<options/>
<params>
<P1 desc="v  (a record, a sequence or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F690>
<F691 desc="Calculate the generalized variance of a vector (sequence)." majortype="101" name="var" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate sample variance of a vector by dividing by n-1" optionchar="s"/>
</options>
<params>
<P1 desc="V(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F691>
<F692 desc="Implement an operation on file data, such as download and upload." majortype="102" name="webhdfs" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="localFile(The target file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F692>
<F693 desc="Implement file read and write." majortype="102" name="webhdfs_file" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fileUrl(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(Parameter in the file URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F693>
<F694 desc="Select the English words out of a string" majortype="101" name="words" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Select the numbers out of the string s" optionchar="d"/>
<O2 defaultselect="false" description="Select both the English words and the numbers out of the string s" optionchar="a"/>
<O3 defaultselect="false" description="Extract all characters from a string; extract a string in Chinese /a sign as inidvidual characters and a string of English letters/a number as what they are" optionchar="w"/>
<O4 defaultselect="false" description="Use with @w option to identify the preceder of a number or a datetime data as a part of it" optionchar="p"/>
<O5 defaultselect="false" description="Treat English letters in a row and continuous English letters plus numbers as a whole" optionchar="i"/>
</options>
<params/>
</F694>
<F695 desc="Compute a date time of n workdays from the specified date." majortype="102" name="workday" postfix="" returntype="101">
<options/>
<params>
<P1 desc="t (date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (time sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F695>
<F696 desc="Return a sequence of workdays between two dates inclusive" majortype="102" name="workdays" postfix="" returntype="101">
<options/>
<params>
<P1 desc="b (Date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (A sequence composed of data of date type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F696>
<F697 desc="Write string or a sequence into a file object. The write-in string can be binary data." majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="s  (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F697>
<F698 desc="Convert every member in the sequence A to a string and write to the file f; each member occupies one row" majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="A (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F698>
<F699 desc="Send a query request to the web service server to get the returned data" majortype="102" name="ws_call" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Web service client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="service_name (Service name; the parameter can be omitted when the WSDL URL contains only one service)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="service_port (Service port; the parameter can be omitted when the specified service has only one port )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="operation_name (Query operation name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="value: paramName (Parameter value&amp;Parameter name; multiple pairs are allowed. If the name part is omitted, names defined in WDSL message will be referenced in order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F699>
<F700 desc="Create a web service client" majortype="102" name="ws_client" postfix="" returntype="101">
<options/>
<params>
<P1 desc="wsdl_url (The WSDL URL provided by the server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F700>
<F701 desc="Cross-join multiple sequences together." majortype="102" name="xjoin" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in sequence Ai" optionchar="1"/>
</options>
<params>
<P1 desc="Ai (The sequence on which cross-join is to be performed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field names of the resulting TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Criterion of filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F701>
<F702 desc="Perform cross join over single cursors or table sequences" majortype="102" name="xjoinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in cursors csi" optionchar="1"/>
<O2 defaultselect="false" description="If field values of the sequences to be joined are records, the joining values will be unfolded" optionchar="x"/>
</options>
<params>
<P1 desc="csi (Single cursors or table sequences to be joined)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Names of fields of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F702>
<F703 desc="Enter cell values to an Excel file object or read data from it." majortype="101" name="xlscell" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Insert a row after the row containing cell a and enter the specified data; by default there won’t be insertion and the existing data will be overwritten" optionchar="i"/>
<O2 defaultselect="false" description="Enable returning a sequence of sequences of cell values at read-in" optionchar="w"/>
<O3 defaultselect="false" description="Parameter :b will be absent and parameter t is blob type when using this option to read in or configure an image; support jpg an pnag only" optionchar="g"/>
<O4 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O5 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="a (Cell a)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Cell b; when omitted, it is the last non-empty cell)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (Page number/page name; it is the first page when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="t (The to-be-populated string; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F703>
<F704 desc="Close an Excel file object." majortype="101" name="xlsclose" postfix="xo." returntype="102">
<options/>
<params/>
</F704>
<F705 desc="Write a table sequence or a cursor to an Excel file." majortype="101" name="xlsexport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the first record as the header into a file; when a namesake file with content already exists, the last non-empty row will be treated as the header row" optionchar="t"/>
<O2 defaultselect="false" description="Import a whole big file (but shouldn’t be too big) with stream style" optionchar="c"/>
<O3 defaultselect="false" description="Write data after the last row according to the current format if the Excel file exists" optionchar="a"/>
<O4 defaultselect="false" description="Use this option when parameter A is a sequence of sequences or a string delimited by /tab; it cannot work with both @t and @c, and requires the absence of parameters x:F" optionchar="w"/>
<O5 defaultselect="false" description="If the table sequence/cursor to be exported is a sequence of sequence, use this option to transpose rows to columns before writing data to a target Excel file; the option must work with @w option" optionchar="p"/>
</options>
<params>
<P1 desc="A(Table sequence/cursor to be exported)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Fields to be exported. If omitted, then export all fields which can be textualized in the record sequence A/cursor. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Resulting field name; if omitted, then use the original field names)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s(Sheet name or sheet number; when omitted, the exported data will be appended to the first sheet)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="p(The password for opening the exported Excel file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F705>
<F706 desc="Write a sequence into an Excel file object." majortype="101" name="xlsexport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Export headers; headers will overwrite the last row if there is data already " optionchar="t"/>
</options>
<params>
<P1 desc="A (A cursor/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (To-be-entered field names; all fields will be populated when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (The alias of the Excel file; use the original name when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (Page name/page number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F706>
<F707 desc="Retrieve contents as record from Excel file object, and return in the form of TSeq" majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
</options>
<params/>
</F707>
<F708 desc="From f, retrieve the data of entire rows from contents of b to e, and return in the form of TSeq. The &quot;e&lt;0&quot; represents the reciprocal number, and &quot;Fi&quot; represents the retrieved fields. By default, all fields will be retrieved. s is the name or sequence number of sheet." majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
<O2 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O3 defaultselect="false" description="Enable returning a sequence of sequences where members of sub-sequences are cell values; it cannot work with @t, @c and @b options" optionchar="w"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (To-be-retrieved fields; by default all fields will be retrieved.The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (sheet name or sequence number. If s is omitted, use the first Excel sheet.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The starting row. If b is omitted, the data from the first row to the row e will be retrieved. In this case, &quot;:&quot; can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (The ending row. If e is omitted, the data will be retrieved from the row b to the last row. In this case, &quot;:&quot; cannot be omitted. If e is greater than the actual number of rows, then the actual number of rows shall prevail.         If both b and e are omitted, the data will be retrieved from the first row to the last row. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F708>
<F709 desc="Retrieve a table sequence from an Excel file object." majortype="101" name="xlsimport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="The first row is the header row; when parameter b is present, the header row is row b" optionchar="t"/>
<O2 defaultselect="false" description="Return the retrieved table sequence as a cursor; here the Excel file object must be read with @r option" optionchar="c"/>
<O3 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (Excel column name; retrieve all fields when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Page name/page number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Row number; the first row by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (Row number; when e &lt; 0, it is the row counted backwards; retrieve data to the last row when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F709>
<F710 desc="Read an Excel file and return an Excel file object." majortype="101" name="xlsopen" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read data in a stream style; support only xlsx files" optionchar="r"/>
<O2 defaultselect="false" description="Write data in a stream style; doesn’t support returning the index and support only xlsx files; the option and @r option are mutually exclusive" optionchar="w"/>
</options>
<params>
<P1 desc="p (The password for opening an Excel file; can be omitted if no password is set for the to-be-opened file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F710>
<F711 desc="Save an Excel file object into an Excel file." majortype="101" name="xlswrite" postfix="f." returntype="101">
<options/>
<params>
<P1 desc="xo (An Excel object read in non-@r@w way)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p (The password for opening an Excel file; by default there isn’t one)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F711>
<F712 desc="Parse an XML string/a table sequence and return result." majortype="102" name="xml" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The options enables parsing an XML string in the format of K F=v F=v …&gt;D&lt;/K&gt; into records made up of fields K,F,… Three situations: If K’s value is D and D is multilevel XML data, the parsing result is a record sequence; if &lt;K …./K&gt;, D is parsed into null; if &lt;K…&gt;&lt;/K&gt;, D is parsed into an empty string." optionchar="s"/>
</options>
<params>
<P1 desc="x(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F712>
<F713 desc="Perform XOR operation on integers" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expresion based on which you perform the XOR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F713>
<F714 desc="Perform XOR operation on integers" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F714>
<F715 desc="Generate a new sequence by uniting and rearranging distinct members in each of a sequence’s sub-sequences" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params/>
</F715>
<F716 desc="Calculate an expression with each member of every sub-sequence of a sequence to generate a new sequence by uniting and rearranging distinct members in each of the resulting sub-sequences" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x(An expression whose value is a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F716>
<F717 desc="Get the year from a date" majortype="102" name="year" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp   (Expression whose result is a date or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F717>
<F718 desc="Perform model building operation" majortype="102" name="ym_build_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD model)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F718>
<F719 desc="Release resource usage." majortype="102" name="ym_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F719>
<F720 desc="Initialize the environment by setting an environment variable.      ym_env(1) forces a restart of Python service." majortype="102" name="ym_env" postfix="" returntype="101">
<options/>
<params/>
</F720>
<F721 desc="Execute a Python file to define a data file and the target variable for data scoring." majortype="101" name="ym_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pyfile(A Python module file that implements def apply(lists) interface; parameter lists is the list data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(A data file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="jsonstr(A JSON string like: {target:0,n_components:3,deflation_mode:'regression',                 mode:'A',norm_y_weights:False,                  scale:False,algorithm:'nipals',                 max_iter:500,tol:0.000001,copy:True} In which target specifies the column holding the target variable  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F721>
<F722 desc="List the degrees of importance for model building variables" majortype="102" name="ym_importance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F722>
<F723 desc="Return model information as a JSON string." majortype="101" name="ym_json" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(The model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F723>
<F724 desc="Generate a model object based on the model building file." majortype="101" name="ym_load_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pdfile(A model building file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F724>
<F725 desc="Load data for model building" majortype="102" name="ym_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(Data for model building)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F725>
<F726 desc="Get information about the performance of a model" majortype="102" name="ym_performance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F726>
<F727 desc="Perform data scoring.    Return a table sequence of scoring results when the data to be scored is a single record or concurrent records;     Return scoring result object when the data to be scored contains multiple records or it is a file. " majortype="102" name="ym_predict" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The function @m(pd,data;duration) performs data scoring with a parallel processing. Parameter duration defines a time period (Unit: millisecond) during which the data is to be scored." optionchar="m"/>
</options>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(To-be-scored data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F727>
<F728 desc="Get model description data" majortype="102" name="ym_present" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F728>
<F729 desc="Get data from the scoring result object." majortype="102" name="ym_result" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F729>
<F730 desc="Generate a model file according to a model object." majortype="101" name="ym_save_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F730>
<F731 desc="Close Python service." majortype="102" name="ym_server_quit" postfix="" returntype="102">
<options/>
<params/>
</F731>
<F732 desc="Set model building parameter" majortype="102" name="ym_setparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key(A parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="value(A parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F732>
<F733 desc="Get a series of information about a specified variable" majortype="102" name="ym_statistics" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="field(Variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F733>
<F734 desc="Set a target variable for model building" majortype="102" name="ym_target" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="targetName(Target variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F734>
<F735 desc="Divide a set of natural numbers into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (Integer; the sequence number of a member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Integer; the length of a subset.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F735>
<F736 desc="Create a multidimensional matrix where all the elements are zero." majortype="102" name="zeros" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F736>
<F737 desc="Perform file compression operations" majortype="102" name="zip" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decompression" optionchar="u"/>
<O2 defaultselect="false" description="Append a new compressed file to an existing compressed file" optionchar="a"/>
<O3 defaultselect="false" description="Delete a file in a compressed file" optionchar="d"/>
<O4 defaultselect="false" description="Won’t perform recursive compression over subdirectories, only compress files of the current level" optionchar="n"/>
<O5 defaultselect="false" description="List files in a compressed file" optionchar="f"/>
<O6 defaultselect="false" description="List directories in a compressed file" optionchar="p"/>
</options>
<params>
<P1 desc="zipfile(A compressed file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="encoding(Charset; default is utf-8)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="password (A password; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="path(The root directory holding a to-be-compressed file; it is the directory holding zipfile when the parameter is null or absent. The comma (“,”) after the parameter should be retained even the parameter is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="files(A file or a sequence of files. Wildcard characters * and ? are allowed in a file name; the former represents any string and the latter represents a single character. With wildcard characters and if the name of the directory where the to-be-compressed file(s) are located isn’t the same with that of the directory holding the future compressed file(s), then the function will also compressed the directory, which contains the absolute path. In that case, the directory list generated via @p option is empty )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F737>
<F738 desc="Add one or more files to a zip file" majortype="102" name="zip_add" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(Name of a to-be-compressed file or FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F738>
<F739 desc=" Close a zip file." majortype="102" name="zip_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F739>
<F740 desc="Set compression mode and level for a would-be zip file" majortype="102" name="zip_compress" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(Compression mode 0: Won’t compress 1: Standard compression  2: AES_ENC mode compression Other values: Standard compression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="level(Compression level 1: DEFLATE_LEVEL_FASTEST 2: DEFLATE_LEVEL_FAST 3: DEFLATE_LEVEL_NORMAL 4: DEFLATE_LEVEL_MAXIMUM 5: DEFLATE_LEVEL_ULTRA Other values: DEFLATE_LEVEL_NORMAL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F740>
<F741 desc=" Delete one or more files from a zip file" majortype="102" name="zip_del" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file ovject)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F741>
<F742 desc="Set encryption mode for a zip file" majortype="102" name="zip_encrypt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(0: Won’t encrypt 1: Standard encryption 2: AES encryption with key length 128 3: AES encryption with key length 192 4: AES encryption with key length 256 Other values:Won’t encrypt)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F742>
<F743 desc="Extract one or more files from a zip file" majortype="102" name="zip_extract" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F743>
<F744 desc="Get an integer consisting of certain bytes of a serial byte key" majortype="101" name="sbs" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="a (The ath byte of serial byte k; begin from the first byte when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The bth byte of serial byte k; stop at he last byte when this parameter is absent, and get the ath byte only when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F744>
<F745 desc="Divide a set with length of n into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (The sequence number of a member, which is an integer and meets i&lt;=n)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (The length of each subset, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (Length of the set, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F745>
<F746 desc="The function gets multiple substrings from string s to form a new string" majortype="101" name="sbs" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="a (The start position for getting the future substrings; default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The end position for getting the future substrings, whose defaut is s.len(); let b=a when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F746>
<F747 desc="Get information about base members at a superior level in a multilayer loop function" majortype="102" name="get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="level (The number of levels between the current level, which is recorded as 0, and the desired superior level)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name, which is sometimes represented by #, denoting the ordial number of a field; get members directly when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="a (Expression of the ordinal number of a member; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="b (Expression of the ordinal number of a member; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F747>
<F748 desc="Join up multiple pseudo tables" majortype="102" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join; if no matching records are found, then use nulls to correspond" optionchar="f"/>
<O2 defaultselect="false" description="Left join; note that it is the number “1”, instead of letter “l”" optionchar="1"/>
<O3 defaultselect="false" description="Perform the join according to positions while ignoring the parameter xj" optionchar="p"/>
</options>
<params>
<P1 desc="Ti (Pseudo tables being joined)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of the result pseudo table)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (The join field or join expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F748>
<F749 desc="Generate a pseudo table definition object" majortype="102" name="pseudo" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd (A pseudo table definition record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F749>
<F750 desc="Append-write records of a cursor to a pseudo table" majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Perform append-write through MERGE" optionchar="m"/>
<O2 defaultselect="false" description="Append-write immediately at exit of the program or at retrieval while, by default, perform the operation when the number of records reaches to a specified number" optionchar="i"/>
<O3 defaultselect="false" description="MERGE append-write to a patch file, which will be created if there isn’t one" optionchar="a"/>
<O4 defaultselect="false" description="Calculate the zone table expression is at each append when append-writing data in a single cursor to a pseudo table whose source composite table is a multi-zone one because the cursor could correspond to multiple zones" optionchar="x"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F750>
<F751 desc="Get a cursor based on a pseudo table object" majortype="101" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in a result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F751>
<F752 desc="Delete one or more specified records from a pseudo table" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="P (A record sequence having the same structure with T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F752>
<F753 desc="Group records of a pseudo table by comparing the grouping field in each with its next neighbor." majortype="101" name="group" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="x is a boolean expression. Begin a new group when a record makes it return true. In this case there should be only one x" optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it; here it is number 1, instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Return result as a table sequence on which an index can be directly created; by default, the function sorts the result" optionchar="t"/>
</options>
<params>
<P1 desc="xi (Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F753>
<F754 desc="Group records in a pseudo table" majortype="101" name="groups" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first" optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by the grouping expression; it doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a boolean expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O6 defaultselect="false" description="Enable returning a resut set containing aggregates only without group-level data" optionchar="b"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon “;” must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on T, which only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F754>
<F755 desc="Get a table sequence based on a pseudo table" majortype="101" name="import" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F755>
<F756 desc="Select records from a pseudo table according to a specified condition." majortype="101" name="select" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x (A Boolean expression that is a filter condition, which can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F756>
<F757 desc="Update records in a pseudo table" majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Only append or insert non-matching records and ignore the matching ones" optionchar="i"/>
<O2 defaultselect="false" description="Only update the matching records and ignore the non-matching ones" optionchar="u"/>
<O3 defaultselect="false" description="Return records that are updated and inserted" optionchar="n"/>
<O4 defaultselect="false" description="When parameter P is a cursor having same order as the original entity table, update the latter’s fields that P has; only valid for column-wise storage format and no records should be added" optionchar="w"/>
</options>
<params>
<P1 desc="P (A table sequence/record sequence having same structure as T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F757>
<F758 desc="Calculate remainder for degree to radian conversion" majortype="102" name="remainder" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(An integer or a real number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An integer or a real number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F758>
<F759 desc="Convert a string, two-level sequence, table sequence or record sequence to a specific type" majortype="102" name="E" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not use headers" optionchar="b"/>
<O2 defaultselect="false" description="Transpose the two-level sequence" optionchar="p"/>
<O3 defaultselect="false" description="Return a string separated by carriage return or tab when parameter x is a table sequence" optionchar="s"/>
</options>
<params>
<P1 desc="x(A sequence/string/table sequence/record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F759>
</normal>
</funcs>
